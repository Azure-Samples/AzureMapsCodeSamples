/* MIT License - Copyright (c) Microsoft Corporation. */


!function (d, p, u) { "use strict"; var n = "default" in p ? p.default : p, o = function (e, r) { return (o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, r) { e.__proto__ = r } || function (e, r) { for (var t in r) r.hasOwnProperty(t) && (e[t] = r[t]) })(e, r) }; function e(e, r) { function t() { this.constructor = e } o(e, r), e.prototype = null === r ? Object.create(r) : (t.prototype = r.prototype, new t) } var a = function () { return (a = Object.assign || function (e) { for (var r, t = 1, n = arguments.length; t < n; t++)for (var o in r = arguments[t]) Object.prototype.hasOwnProperty.call(r, o) && (e[o] = r[o]); return e }).apply(this, arguments) }, r = (t.merge = function (e, r) { for (var t = window || global, n = 0, o = e.split("."); n < o.length; n++) { var i = o[n]; if (!t[i]) return r; t = t[i] } return a(a({}, t), r) }, t); function t() { } function i(e, r) { if (!(t = r = r || {}) || t.constructor !== Object) throw new Error("options is invalid"); var t, n = r.bbox, o = r.id; if (!e) throw new Error("No features passed"); if (!Array.isArray(e)) throw new Error("features must be an Array"); n && function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (r = e, isNaN(r) || null === r || Array.isArray(r)) throw new Error("bbox must only contain numbers"); var r }) }(n), o && function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }(o); var i = { type: "FeatureCollection" }; return o && (i.id = o), n && (i.bbox = n), i.features = e, i } function s(e, r, t) { if ("object" != typeof (t = t || {})) throw new Error("options is invalid"); var n = t.ignoreBoundary; if (!e) throw new Error("point is required"); if (!r) throw new Error("polygon is required"); var o = function (e) { if (!e) throw new Error("coord is required"); if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates; if (Array.isArray(e) && 2 <= e.length && void 0 === e[0].length && void 0 === e[1].length) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") }(e), i = function (e) { if (!e) throw new Error("coords is required"); if ("Feature" === e.type && null !== e.geometry) return e.geometry.coordinates; if (e.coordinates) return e.coordinates; if (Array.isArray(e)) return e; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }(r), a = r.geometry ? r.geometry.type : r.type, s = r.bbox; if (!s || !1 != (u = o, (l = s)[0] <= u[0] && l[1] <= u[1] && l[2] >= u[0] && l[3] >= u[1])) { var u, l; "Polygon" === a && (i = [i]); for (var c = 0, d = !1; c < i.length && !d; c++)if (m(o, i[c][0], n)) { for (var g = !1, f = 1; f < i[c].length && !g;)m(o, i[c][f], !n) && (g = !0), f++; g || (d = !0) } return d } } function m(e, r, t) { var n = !1; r[0][0] === r[r.length - 1][0] && r[0][1] === r[r.length - 1][1] && (r = r.slice(0, r.length - 1)); for (var o = 0, i = r.length - 1; o < r.length; i = o++) { var a = r[o][0], s = r[o][1], u = r[i][0], l = r[i][1]; if (e[1] * (a - u) + s * (u - e[0]) + l * (e[0] - a) == 0 && (a - e[0]) * (u - e[0]) <= 0 && (s - e[1]) * (l - e[1]) <= 0) return !t; s > e[1] != l > e[1] && e[0] < (u - a) * (e[1] - s) / (l - s) + a && (n = !n) } return n } function l(e, r) { var t = []; return function (e, r) { var t, n, o, i, a, s, u, l, c, d, g = 0, f = "FeatureCollection" === e.type, m = "Feature" === e.type, h = f ? e.features.length : 1; for (t = 0; t < h; t++) { for (s = f ? e.features[t].geometry : m ? e.geometry : e, l = f ? e.features[t].properties : m ? e.properties : {}, c = f ? e.features[t].bbox : m ? e.bbox : void 0, d = f ? e.features[t].id : m ? e.id : void 0, a = (u = !!s && "GeometryCollection" === s.type) ? s.geometries.length : 1, o = 0; o < a; o++)if (null !== (i = u ? s.geometries[o] : s)) switch (i.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === r(i, g, l, c, d)) return; break; case "GeometryCollection": for (n = 0; n < i.geometries.length; n++)if (!1 === r(i.geometries[n], g, l, c, d)) return; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === r(null, g, l, c, d)) return; g++ } }(r, function (r) { !function (e, r) { if ("Feature" === e.type) r(e, 0); else if ("FeatureCollection" === e.type) for (var t = 0; t < e.features.length && !1 !== r(e.features[t], t); t++); }(e, function (e) { s(e, r) && t.push(e) }) }), i(t) } var b = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function c(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } function g(e, r) { return e(r = { exports: {} }, r.exports), r.exports } var h = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(h); h.earthRadius, h.factors, h.unitsFactors, h.areaFactors, h.feature, h.geometry, h.point, h.points, h.polygon, h.polygons, h.lineString, h.lineStrings, h.featureCollection, h.multiLineString, h.multiPoint, h.multiPolygon, h.geometryCollection, h.round, h.radiansToLength, h.lengthToRadians, h.lengthToDegrees, h.bearingToAzimuth, h.radiansToDegrees, h.degreesToRadians, h.convertLength, h.convertArea, h.isNumber, h.isObject, h.validateBBox, h.validateId, h.radians2degrees, h.degrees2radians, h.distanceToDegrees, h.distanceToRadians, h.radiansToDistance, h.bearingToAngle, h.convertDistance; var f = g(function (e, r) { function P(e, r, t) { if (null !== e) for (var n, o, i, a, s, u, l, c, d = 0, g = 0, f = e.type, m = "FeatureCollection" === f, h = "Feature" === f, p = m ? e.features.length : 1, y = 0; y < p; y++) { s = (c = !!(l = m ? e.features[y].geometry : h ? e.geometry : e) && "GeometryCollection" === l.type) ? l.geometries.length : 1; for (var v = 0; v < s; v++) { var b = 0, w = 0; if (null !== (a = c ? l.geometries[v] : l)) { u = a.coordinates; var k = a.type; switch (d = !t || "Polygon" !== k && "MultiPolygon" !== k ? 0 : 1, k) { case null: break; case "Point": if (!1 === r(u, g, y, b, w)) return !1; g++, b++; break; case "LineString": case "MultiPoint": for (n = 0; n < u.length; n++) { if (!1 === r(u[n], g, y, b, w)) return !1; g++, "MultiPoint" === k && b++ } "LineString" === k && b++; break; case "Polygon": case "MultiLineString": for (n = 0; n < u.length; n++) { for (o = 0; o < u[n].length - d; o++) { if (!1 === r(u[n][o], g, y, b, w)) return !1; g++ } "MultiLineString" === k && b++, "Polygon" === k && w++ } "Polygon" === k && b++; break; case "MultiPolygon": for (n = 0; n < u.length; n++) { for (o = w = 0; o < u[n].length; o++) { for (i = 0; i < u[n][o].length - d; i++) { if (!1 === r(u[n][o][i], g, y, b, w)) return !1; g++ } w++ } b++ } break; case "GeometryCollection": for (n = 0; n < a.geometries.length; n++)if (!1 === P(a.geometries[n], r, t)) return !1; break; default: throw new Error("Unknown Geometry Type") } } } } } function i(e, r) { var t; switch (e.type) { case "FeatureCollection": for (t = 0; t < e.features.length && !1 !== r(e.features[t].properties, t); t++); break; case "Feature": r(e.properties, 0) } } function a(e, r) { if ("Feature" === e.type) r(e, 0); else if ("FeatureCollection" === e.type) for (var t = 0; t < e.features.length && !1 !== r(e.features[t], t); t++); } function t(e, r) { var t, n, o, i, a, s, u, l, c, d, g = 0, f = "FeatureCollection" === e.type, m = "Feature" === e.type, h = f ? e.features.length : 1; for (t = 0; t < h; t++) { for (s = f ? e.features[t].geometry : m ? e.geometry : e, l = f ? e.features[t].properties : m ? e.properties : {}, c = f ? e.features[t].bbox : m ? e.bbox : void 0, d = f ? e.features[t].id : m ? e.id : void 0, a = (u = !!s && "GeometryCollection" === s.type) ? s.geometries.length : 1, o = 0; o < a; o++)if (null !== (i = u ? s.geometries[o] : s)) switch (i.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === r(i, g, l, c, d)) return !1; break; case "GeometryCollection": for (n = 0; n < i.geometries.length; n++)if (!1 === r(i.geometries[n], g, l, c, d)) return !1; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === r(null, g, l, c, d)) return !1; g++ } } function s(e, l) { t(e, function (e, r, t, n, o) { var i, a = null === e ? null : e.type; switch (a) { case null: case "Point": case "LineString": case "Polygon": return !1 === l(h.feature(e, t, { bbox: n, id: o }), r, 0) ? !1 : void 0 }switch (a) { case "MultiPoint": i = "Point"; break; case "MultiLineString": i = "LineString"; break; case "MultiPolygon": i = "Polygon" }for (var s = 0; s < e.coordinates.length; s++) { var u = { type: i, coordinates: e.coordinates[s] }; if (!1 === l(h.feature(u, t), r, s)) return !1 } }) } function n(e, m) { s(e, function (a, s, u) { var l = 0; if (a.geometry) { var e = a.geometry.type; if ("Point" !== e && "MultiPoint" !== e) { var c, d = 0, g = 0, f = 0; return !1 !== P(a, function (e, r, t, n, o) { if (void 0 === c || d < s || g < n || f < o) return c = e, d = s, g = n, f = o, void (l = 0); var i = h.lineString([c, e], a.properties); if (!1 === m(i, s, u, o, l)) return !1; l++, c = e }) && void 0 } } }) } function u(e, a) { if (!e) throw new Error("geojson is required"); s(e, function (e, r, t) { if (null !== e.geometry) { var n = e.geometry.type, o = e.geometry.coordinates; switch (n) { case "LineString": if (!1 === a(e, r, t, 0, 0)) return !1; break; case "Polygon": for (var i = 0; i < o.length; i++)if (!1 === a(h.lineString(o[i], e.properties), r, t, i)) return !1 } } }) } Object.defineProperty(r, "__esModule", { value: !0 }), r.coordEach = P, r.coordReduce = function (e, i, a, r) { var s = a; return P(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }, r), s }, r.propEach = i, r.propReduce = function (e, t, n) { var o = n; return i(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.featureEach = a, r.featureReduce = function (e, t, n) { var o = n; return a(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.coordAll = function (e) { var r = []; return P(e, function (e) { r.push(e) }), r }, r.geomEach = t, r.geomReduce = function (e, i, a) { var s = a; return t(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }), s }, r.flattenEach = s, r.flattenReduce = function (e, n, o) { var i = o; return s(e, function (e, r, t) { i = 0 === r && 0 === t && void 0 === o ? e : n(i, e, r, t) }), i }, r.segmentEach = n, r.segmentReduce = function (e, i, a) { var s = a, u = !1; return n(e, function (e, r, t, n, o) { s = !1 === u && void 0 === a ? e : i(s, e, r, t, n, o), u = !0 }), s }, r.lineEach = u, r.lineReduce = function (e, o, i) { var a = i; return u(e, function (e, r, t, n) { a = 0 === r && void 0 === i ? e : o(a, e, r, t, n) }), a }, r.findSegment = function (e, r) { if (r = r || {}, !h.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.segmentIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": case "MultiPoint": return null; case "LineString": return a < 0 && (a = u.length + a - 1), h.lineString([u[a], u[a + 1]], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a - 1), h.lineString([u[i][a], u[i][a + 1]], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a - 1), h.lineString([u[o][a], u[o][a + 1]], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a - 1), h.lineString([u[o][i][a], u[o][i][a + 1]], s, r) }throw new Error("geojson is invalid") }, r.findPoint = function (e, r) { if (r = r || {}, !h.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.coordIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": return h.point(u, s, r); case "MultiPoint": return o < 0 && (o = u.length + o), h.point(u[o], s, r); case "LineString": return a < 0 && (a = u.length + a), h.point(u[a], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a), h.point(u[i][a], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a), h.point(u[o][a], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a), h.point(u[o][i][a], s, r) }throw new Error("geojson is invalid") } }); c(f); f.coordEach, f.coordReduce, f.propEach, f.propReduce, f.featureEach, f.featureReduce, f.coordAll, f.geomEach, f.geomReduce, f.flattenEach, f.flattenReduce, f.segmentEach, f.segmentReduce, f.lineEach, f.lineReduce, f.findSegment, f.findPoint; var y = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.getCoord = function (e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && 2 <= e.length && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") }, r.getCoords = function (e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }, r.containsNumber = function e(r) { if (1 < r.length && h.isNumber(r[0]) && h.isNumber(r[1])) return !0; if (Array.isArray(r[0]) && r[0].length) return e(r[0]); throw new Error("coordinates must only contain numbers") }, r.geojsonType = function (e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) }, r.featureOf = function (e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) }, r.collectionOf = function (e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var n = 0, o = e.features; n < o.length; n++) { var i = o[n]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } }, r.getGeom = function (e) { return "Feature" === e.type ? e.geometry : e }, r.getType = function (e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } }); c(y); y.getCoord, y.getCoords, y.containsNumber, y.geojsonType, y.featureOf, y.collectionOf, y.getGeom, y.getType; var v = g(function (e, r) { function p(e, r, t) { var n = e[r]; e[r] = e[t], e[t] = n } function i(e, r) { return e < r ? -1 : r < e ? 1 : 0 } e.exports = function (e, r, t, n, o) { !function e(r, t, n, o, i) { for (; n < o;) { if (600 < o - n) { var a = o - n + 1, s = t - n + 1, u = Math.log(a), l = .5 * Math.exp(2 * u / 3), c = .5 * Math.sqrt(u * l * (a - l) / a) * (s - a / 2 < 0 ? -1 : 1), d = Math.max(n, Math.floor(t - s * l / a + c)), g = Math.min(o, Math.floor(t + (a - s) * l / a + c)); e(r, t, d, g, i) } var f = r[t], m = n, h = o; for (p(r, n, t), 0 < i(r[o], f) && p(r, n, o); m < h;) { for (p(r, m, h), m++, h--; i(r[m], f) < 0;)m++; for (; 0 < i(r[h], f);)h-- } 0 === i(r[n], f) ? p(r, n, h) : p(r, ++h, o), h <= t && (n = h + 1), t <= h && (o = h - 1) } }(e, r, t || 0, n || e.length - 1, o || i) } }), w = P, k = P; function P(e, r) { if (!(this instanceof P)) return new P(e, r); this._maxEntries = Math.max(4, e || 9), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), r && this._initFormat(r), this.clear() } function E(e, r, t) { if (!t) return r.indexOf(e); for (var n = 0; n < r.length; n++)if (t(e, r[n])) return n; return -1 } function S(e, r) { T(e, 0, e.children.length, r, e) } function T(e, r, t, n, o) { (o = o || L(null)).minX = 1 / 0, o.minY = 1 / 0, o.maxX = -1 / 0, o.maxY = -1 / 0; for (var i, a = r; a < t; a++)i = e.children[a], M(o, e.leaf ? n(i) : i); return o } function M(e, r) { return e.minX = Math.min(e.minX, r.minX), e.minY = Math.min(e.minY, r.minY), e.maxX = Math.max(e.maxX, r.maxX), e.maxY = Math.max(e.maxY, r.maxY), e } function A(e, r) { return e.minX - r.minX } function R(e, r) { return e.minY - r.minY } function C(e) { return (e.maxX - e.minX) * (e.maxY - e.minY) } function x(e) { return e.maxX - e.minX + (e.maxY - e.minY) } function F(e, r) { return e.minX <= r.minX && e.minY <= r.minY && r.maxX <= e.maxX && r.maxY <= e.maxY } function O(e, r) { return r.minX <= e.maxX && r.minY <= e.maxY && r.maxX >= e.minX && r.maxY >= e.minY } function L(e) { return { children: e, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } } function _(e, r, t, n, o) { for (var i, a = [r, t]; a.length;)(t = a.pop()) - (r = a.pop()) <= n || (i = r + Math.ceil((t - r) / n / 2) * n, v(e, i, r, t, o), a.push(r, i, i, t)) } P.prototype = { all: function () { return this._all(this.data, []) }, search: function (e) { var r = this.data, t = [], n = this.toBBox; if (!O(e, r)) return t; for (var o, i, a, s, u = []; r;) { for (o = 0, i = r.children.length; o < i; o++)a = r.children[o], O(e, s = r.leaf ? n(a) : a) && (r.leaf ? t.push(a) : F(e, s) ? this._all(a, t) : u.push(a)); r = u.pop() } return t }, collides: function (e) { var r = this.data, t = this.toBBox; if (!O(e, r)) return !1; for (var n, o, i, a, s = []; r;) { for (n = 0, o = r.children.length; n < o; n++)if (i = r.children[n], O(e, a = r.leaf ? t(i) : i)) { if (r.leaf || F(e, a)) return !0; s.push(i) } r = s.pop() } return !1 }, load: function (e) { if (!e || !e.length) return this; if (e.length < this._minEntries) { for (var r = 0, t = e.length; r < t; r++)this.insert(e[r]); return this } var n = this._build(e.slice(), 0, e.length - 1, 0); if (this.data.children.length) if (this.data.height === n.height) this._splitRoot(this.data, n); else { if (this.data.height < n.height) { var o = this.data; this.data = n, n = o } this._insert(n, this.data.height - n.height - 1, !0) } else this.data = n; return this }, insert: function (e) { return e && this._insert(e, this.data.height - 1), this }, clear: function () { return this.data = L([]), this }, remove: function (e, r) { if (!e) return this; for (var t, n, o, i, a = this.data, s = this.toBBox(e), u = [], l = []; a || u.length;) { if (a || (a = u.pop(), n = u[u.length - 1], t = l.pop(), i = !0), a.leaf && -1 !== (o = E(e, a.children, r))) return a.children.splice(o, 1), u.push(a), this._condense(u), this; i || a.leaf || !F(a, s) ? n ? (t++, a = n.children[t], i = !1) : a = null : (u.push(a), l.push(t), t = 0, a = (n = a).children[0]) } return this }, toBBox: function (e) { return e }, compareMinX: A, compareMinY: R, toJSON: function () { return this.data }, fromJSON: function (e) { return this.data = e, this }, _all: function (e, r) { for (var t = []; e;)e.leaf ? r.push.apply(r, e.children) : t.push.apply(t, e.children), e = t.pop(); return r }, _build: function (e, r, t, n) { var o, i = t - r + 1, a = this._maxEntries; if (i <= a) return S(o = L(e.slice(r, t + 1)), this.toBBox), o; n || (n = Math.ceil(Math.log(i) / Math.log(a)), a = Math.ceil(i / Math.pow(a, n - 1))), (o = L([])).leaf = !1, o.height = n; var s, u, l, c, d = Math.ceil(i / a), g = d * Math.ceil(Math.sqrt(a)); for (_(e, r, t, g, this.compareMinX), s = r; s <= t; s += g)for (_(e, s, l = Math.min(s + g - 1, t), d, this.compareMinY), u = s; u <= l; u += d)c = Math.min(u + d - 1, l), o.children.push(this._build(e, u, c, n - 1)); return S(o, this.toBBox), o }, _chooseSubtree: function (e, r, t, n) { for (var o, i, a, s, u, l, c, d, g, f; n.push(r), !r.leaf && n.length - 1 !== t;) { for (c = d = 1 / 0, o = 0, i = r.children.length; o < i; o++)u = C(a = r.children[o]), g = e, f = a, (l = (Math.max(f.maxX, g.maxX) - Math.min(f.minX, g.minX)) * (Math.max(f.maxY, g.maxY) - Math.min(f.minY, g.minY)) - u) < d ? (d = l, c = u < c ? u : c, s = a) : l === d && u < c && (c = u, s = a); r = s || r.children[0] } return r }, _insert: function (e, r, t) { var n = this.toBBox, o = t ? e : n(e), i = [], a = this._chooseSubtree(o, this.data, r, i); for (a.children.push(e), M(a, o); 0 <= r && i[r].children.length > this._maxEntries;)this._split(i, r), r--; this._adjustParentBBoxes(o, i, r) }, _split: function (e, r) { var t = e[r], n = t.children.length, o = this._minEntries; this._chooseSplitAxis(t, o, n); var i = this._chooseSplitIndex(t, o, n), a = L(t.children.splice(i, t.children.length - i)); a.height = t.height, a.leaf = t.leaf, S(t, this.toBBox), S(a, this.toBBox), r ? e[r - 1].children.push(a) : this._splitRoot(t, a) }, _splitRoot: function (e, r) { this.data = L([e, r]), this.data.height = e.height + 1, this.data.leaf = !1, S(this.data, this.toBBox) }, _chooseSplitIndex: function (e, r, t) { var n, o, i, a, s, u, l, c, d, g, f, m, h, p; for (u = l = 1 / 0, n = r; n <= t - r; n++)o = T(e, 0, n, this.toBBox), i = T(e, n, t, this.toBBox), d = o, g = i, 0, f = Math.max(d.minX, g.minX), m = Math.max(d.minY, g.minY), h = Math.min(d.maxX, g.maxX), p = Math.min(d.maxY, g.maxY), a = Math.max(0, h - f) * Math.max(0, p - m), s = C(o) + C(i), a < u ? (u = a, c = n, l = s < l ? s : l) : a === u && s < l && (l = s, c = n); return c }, _chooseSplitAxis: function (e, r, t) { var n = e.leaf ? this.compareMinX : A, o = e.leaf ? this.compareMinY : R; this._allDistMargin(e, r, t, n) < this._allDistMargin(e, r, t, o) && e.children.sort(n) }, _allDistMargin: function (e, r, t, n) { e.children.sort(n); var o, i, a = this.toBBox, s = T(e, 0, r, a), u = T(e, t - r, t, a), l = x(s) + x(u); for (o = r; o < t - r; o++)i = e.children[o], M(s, e.leaf ? a(i) : i), l += x(s); for (o = t - r - 1; r <= o; o--)i = e.children[o], M(u, e.leaf ? a(i) : i), l += x(u); return l }, _adjustParentBBoxes: function (e, r, t) { for (var n = t; 0 <= n; n--)M(r[n], e) }, _condense: function (e) { for (var r, t = e.length - 1; 0 <= t; t--)0 === e[t].children.length ? 0 < t ? (r = e[t - 1].children).splice(r.indexOf(e[t]), 1) : this.clear() : S(e[t], this.toBBox) }, _initFormat: function (e) { var r = ["return a", " - b", ";"]; this.compareMinX = new Function("a", "b", r.join(e[0])), this.compareMinY = new Function("a", "b", r.join(e[1])), this.toBBox = new Function("a", "return {minX: a" + e[0] + ", minY: a" + e[1] + ", maxX: a" + e[2] + ", maxY: a" + e[3] + "};") } }, w.default = k; var j = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(j); j.earthRadius, j.factors, j.unitsFactors, j.areaFactors, j.feature, j.geometry, j.point, j.points, j.polygon, j.polygons, j.lineString, j.lineStrings, j.featureCollection, j.multiLineString, j.multiPoint, j.multiPolygon, j.geometryCollection, j.round, j.radiansToLength, j.lengthToRadians, j.lengthToDegrees, j.bearingToAzimuth, j.radiansToDegrees, j.degreesToRadians, j.convertLength, j.convertArea, j.isNumber, j.isObject, j.validateBBox, j.validateId, j.radians2degrees, j.degrees2radians, j.distanceToDegrees, j.distanceToRadians, j.radiansToDistance, j.bearingToAngle, j.convertDistance; var I = g(function (e, r) { function P(e, r, t) { if (null !== e) for (var n, o, i, a, s, u, l, c, d = 0, g = 0, f = e.type, m = "FeatureCollection" === f, h = "Feature" === f, p = m ? e.features.length : 1, y = 0; y < p; y++) { s = (c = !!(l = m ? e.features[y].geometry : h ? e.geometry : e) && "GeometryCollection" === l.type) ? l.geometries.length : 1; for (var v = 0; v < s; v++) { var b = 0, w = 0; if (null !== (a = c ? l.geometries[v] : l)) { u = a.coordinates; var k = a.type; switch (d = !t || "Polygon" !== k && "MultiPolygon" !== k ? 0 : 1, k) { case null: break; case "Point": if (!1 === r(u, g, y, b, w)) return !1; g++, b++; break; case "LineString": case "MultiPoint": for (n = 0; n < u.length; n++) { if (!1 === r(u[n], g, y, b, w)) return !1; g++, "MultiPoint" === k && b++ } "LineString" === k && b++; break; case "Polygon": case "MultiLineString": for (n = 0; n < u.length; n++) { for (o = 0; o < u[n].length - d; o++) { if (!1 === r(u[n][o], g, y, b, w)) return !1; g++ } "MultiLineString" === k && b++, "Polygon" === k && w++ } "Polygon" === k && b++; break; case "MultiPolygon": for (n = 0; n < u.length; n++) { for (o = w = 0; o < u[n].length; o++) { for (i = 0; i < u[n][o].length - d; i++) { if (!1 === r(u[n][o][i], g, y, b, w)) return !1; g++ } w++ } b++ } break; case "GeometryCollection": for (n = 0; n < a.geometries.length; n++)if (!1 === P(a.geometries[n], r, t)) return !1; break; default: throw new Error("Unknown Geometry Type") } } } } } function i(e, r) { var t; switch (e.type) { case "FeatureCollection": for (t = 0; t < e.features.length && !1 !== r(e.features[t].properties, t); t++); break; case "Feature": r(e.properties, 0) } } function a(e, r) { if ("Feature" === e.type) r(e, 0); else if ("FeatureCollection" === e.type) for (var t = 0; t < e.features.length && !1 !== r(e.features[t], t); t++); } function t(e, r) { var t, n, o, i, a, s, u, l, c, d, g = 0, f = "FeatureCollection" === e.type, m = "Feature" === e.type, h = f ? e.features.length : 1; for (t = 0; t < h; t++) { for (s = f ? e.features[t].geometry : m ? e.geometry : e, l = f ? e.features[t].properties : m ? e.properties : {}, c = f ? e.features[t].bbox : m ? e.bbox : void 0, d = f ? e.features[t].id : m ? e.id : void 0, a = (u = !!s && "GeometryCollection" === s.type) ? s.geometries.length : 1, o = 0; o < a; o++)if (null !== (i = u ? s.geometries[o] : s)) switch (i.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === r(i, g, l, c, d)) return !1; break; case "GeometryCollection": for (n = 0; n < i.geometries.length; n++)if (!1 === r(i.geometries[n], g, l, c, d)) return !1; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === r(null, g, l, c, d)) return !1; g++ } } function s(e, l) { t(e, function (e, r, t, n, o) { var i, a = null === e ? null : e.type; switch (a) { case null: case "Point": case "LineString": case "Polygon": return !1 === l(j.feature(e, t, { bbox: n, id: o }), r, 0) ? !1 : void 0 }switch (a) { case "MultiPoint": i = "Point"; break; case "MultiLineString": i = "LineString"; break; case "MultiPolygon": i = "Polygon" }for (var s = 0; s < e.coordinates.length; s++) { var u = { type: i, coordinates: e.coordinates[s] }; if (!1 === l(j.feature(u, t), r, s)) return !1 } }) } function n(e, m) { s(e, function (a, s, u) { var l = 0; if (a.geometry) { var e = a.geometry.type; if ("Point" !== e && "MultiPoint" !== e) { var c, d = 0, g = 0, f = 0; return !1 !== P(a, function (e, r, t, n, o) { if (void 0 === c || d < s || g < n || f < o) return c = e, d = s, g = n, f = o, void (l = 0); var i = j.lineString([c, e], a.properties); if (!1 === m(i, s, u, o, l)) return !1; l++, c = e }) && void 0 } } }) } function u(e, a) { if (!e) throw new Error("geojson is required"); s(e, function (e, r, t) { if (null !== e.geometry) { var n = e.geometry.type, o = e.geometry.coordinates; switch (n) { case "LineString": if (!1 === a(e, r, t, 0, 0)) return !1; break; case "Polygon": for (var i = 0; i < o.length; i++)if (!1 === a(j.lineString(o[i], e.properties), r, t, i)) return !1 } } }) } Object.defineProperty(r, "__esModule", { value: !0 }), r.coordEach = P, r.coordReduce = function (e, i, a, r) { var s = a; return P(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }, r), s }, r.propEach = i, r.propReduce = function (e, t, n) { var o = n; return i(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.featureEach = a, r.featureReduce = function (e, t, n) { var o = n; return a(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.coordAll = function (e) { var r = []; return P(e, function (e) { r.push(e) }), r }, r.geomEach = t, r.geomReduce = function (e, i, a) { var s = a; return t(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }), s }, r.flattenEach = s, r.flattenReduce = function (e, n, o) { var i = o; return s(e, function (e, r, t) { i = 0 === r && 0 === t && void 0 === o ? e : n(i, e, r, t) }), i }, r.segmentEach = n, r.segmentReduce = function (e, i, a) { var s = a, u = !1; return n(e, function (e, r, t, n, o) { s = !1 === u && void 0 === a ? e : i(s, e, r, t, n, o), u = !0 }), s }, r.lineEach = u, r.lineReduce = function (e, o, i) { var a = i; return u(e, function (e, r, t, n) { a = 0 === r && void 0 === i ? e : o(a, e, r, t, n) }), a }, r.findSegment = function (e, r) { if (r = r || {}, !j.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.segmentIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": case "MultiPoint": return null; case "LineString": return a < 0 && (a = u.length + a - 1), j.lineString([u[a], u[a + 1]], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a - 1), j.lineString([u[i][a], u[i][a + 1]], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a - 1), j.lineString([u[o][a], u[o][a + 1]], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a - 1), j.lineString([u[o][i][a], u[o][i][a + 1]], s, r) }throw new Error("geojson is invalid") }, r.findPoint = function (e, r) { if (r = r || {}, !j.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.coordIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": return j.point(u, s, r); case "MultiPoint": return o < 0 && (o = u.length + o), j.point(u[o], s, r); case "LineString": return a < 0 && (a = u.length + a), j.point(u[a], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a), j.point(u[i][a], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a), j.point(u[o][a], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a), j.point(u[o][i][a], s, r) }throw new Error("geojson is invalid") } }); c(I); I.coordEach, I.coordReduce, I.propEach, I.propReduce, I.featureEach, I.featureReduce, I.coordAll, I.geomEach, I.geomReduce, I.flattenEach, I.flattenReduce, I.segmentEach, I.segmentReduce, I.lineEach, I.lineReduce, I.findSegment, I.findPoint; var z = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(z); z.earthRadius, z.factors, z.unitsFactors, z.areaFactors, z.feature, z.geometry, z.point, z.points, z.polygon, z.polygons, z.lineString, z.lineStrings, z.featureCollection, z.multiLineString, z.multiPoint, z.multiPolygon, z.geometryCollection, z.round, z.radiansToLength, z.lengthToRadians, z.lengthToDegrees, z.bearingToAzimuth, z.radiansToDegrees, z.degreesToRadians, z.convertLength, z.convertArea, z.isNumber, z.isObject, z.validateBBox, z.validateId, z.radians2degrees, z.degrees2radians, z.distanceToDegrees, z.distanceToRadians, z.radiansToDistance, z.bearingToAngle, z.convertDistance; var D = g(function (e, r) { function P(e, r, t) { if (null !== e) for (var n, o, i, a, s, u, l, c, d = 0, g = 0, f = e.type, m = "FeatureCollection" === f, h = "Feature" === f, p = m ? e.features.length : 1, y = 0; y < p; y++) { s = (c = !!(l = m ? e.features[y].geometry : h ? e.geometry : e) && "GeometryCollection" === l.type) ? l.geometries.length : 1; for (var v = 0; v < s; v++) { var b = 0, w = 0; if (null !== (a = c ? l.geometries[v] : l)) { u = a.coordinates; var k = a.type; switch (d = !t || "Polygon" !== k && "MultiPolygon" !== k ? 0 : 1, k) { case null: break; case "Point": if (!1 === r(u, g, y, b, w)) return !1; g++, b++; break; case "LineString": case "MultiPoint": for (n = 0; n < u.length; n++) { if (!1 === r(u[n], g, y, b, w)) return !1; g++, "MultiPoint" === k && b++ } "LineString" === k && b++; break; case "Polygon": case "MultiLineString": for (n = 0; n < u.length; n++) { for (o = 0; o < u[n].length - d; o++) { if (!1 === r(u[n][o], g, y, b, w)) return !1; g++ } "MultiLineString" === k && b++, "Polygon" === k && w++ } "Polygon" === k && b++; break; case "MultiPolygon": for (n = 0; n < u.length; n++) { for (o = w = 0; o < u[n].length; o++) { for (i = 0; i < u[n][o].length - d; i++) { if (!1 === r(u[n][o][i], g, y, b, w)) return !1; g++ } w++ } b++ } break; case "GeometryCollection": for (n = 0; n < a.geometries.length; n++)if (!1 === P(a.geometries[n], r, t)) return !1; break; default: throw new Error("Unknown Geometry Type") } } } } } function i(e, r) { var t; switch (e.type) { case "FeatureCollection": for (t = 0; t < e.features.length && !1 !== r(e.features[t].properties, t); t++); break; case "Feature": r(e.properties, 0) } } function a(e, r) { if ("Feature" === e.type) r(e, 0); else if ("FeatureCollection" === e.type) for (var t = 0; t < e.features.length && !1 !== r(e.features[t], t); t++); } function t(e, r) { var t, n, o, i, a, s, u, l, c, d, g = 0, f = "FeatureCollection" === e.type, m = "Feature" === e.type, h = f ? e.features.length : 1; for (t = 0; t < h; t++) { for (s = f ? e.features[t].geometry : m ? e.geometry : e, l = f ? e.features[t].properties : m ? e.properties : {}, c = f ? e.features[t].bbox : m ? e.bbox : void 0, d = f ? e.features[t].id : m ? e.id : void 0, a = (u = !!s && "GeometryCollection" === s.type) ? s.geometries.length : 1, o = 0; o < a; o++)if (null !== (i = u ? s.geometries[o] : s)) switch (i.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === r(i, g, l, c, d)) return !1; break; case "GeometryCollection": for (n = 0; n < i.geometries.length; n++)if (!1 === r(i.geometries[n], g, l, c, d)) return !1; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === r(null, g, l, c, d)) return !1; g++ } } function s(e, l) { t(e, function (e, r, t, n, o) { var i, a = null === e ? null : e.type; switch (a) { case null: case "Point": case "LineString": case "Polygon": return !1 === l(z.feature(e, t, { bbox: n, id: o }), r, 0) ? !1 : void 0 }switch (a) { case "MultiPoint": i = "Point"; break; case "MultiLineString": i = "LineString"; break; case "MultiPolygon": i = "Polygon" }for (var s = 0; s < e.coordinates.length; s++) { var u = { type: i, coordinates: e.coordinates[s] }; if (!1 === l(z.feature(u, t), r, s)) return !1 } }) } function n(e, m) { s(e, function (a, s, u) { var l = 0; if (a.geometry) { var e = a.geometry.type; if ("Point" !== e && "MultiPoint" !== e) { var c, d = 0, g = 0, f = 0; return !1 !== P(a, function (e, r, t, n, o) { if (void 0 === c || d < s || g < n || f < o) return c = e, d = s, g = n, f = o, void (l = 0); var i = z.lineString([c, e], a.properties); if (!1 === m(i, s, u, o, l)) return !1; l++, c = e }) && void 0 } } }) } function u(e, a) { if (!e) throw new Error("geojson is required"); s(e, function (e, r, t) { if (null !== e.geometry) { var n = e.geometry.type, o = e.geometry.coordinates; switch (n) { case "LineString": if (!1 === a(e, r, t, 0, 0)) return !1; break; case "Polygon": for (var i = 0; i < o.length; i++)if (!1 === a(z.lineString(o[i], e.properties), r, t, i)) return !1 } } }) } Object.defineProperty(r, "__esModule", { value: !0 }), r.coordEach = P, r.coordReduce = function (e, i, a, r) { var s = a; return P(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }, r), s }, r.propEach = i, r.propReduce = function (e, t, n) { var o = n; return i(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.featureEach = a, r.featureReduce = function (e, t, n) { var o = n; return a(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.coordAll = function (e) { var r = []; return P(e, function (e) { r.push(e) }), r }, r.geomEach = t, r.geomReduce = function (e, i, a) { var s = a; return t(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }), s }, r.flattenEach = s, r.flattenReduce = function (e, n, o) { var i = o; return s(e, function (e, r, t) { i = 0 === r && 0 === t && void 0 === o ? e : n(i, e, r, t) }), i }, r.segmentEach = n, r.segmentReduce = function (e, i, a) { var s = a, u = !1; return n(e, function (e, r, t, n, o) { s = !1 === u && void 0 === a ? e : i(s, e, r, t, n, o), u = !0 }), s }, r.lineEach = u, r.lineReduce = function (e, o, i) { var a = i; return u(e, function (e, r, t, n) { a = 0 === r && void 0 === i ? e : o(a, e, r, t, n) }), a }, r.findSegment = function (e, r) { if (r = r || {}, !z.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.segmentIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": case "MultiPoint": return null; case "LineString": return a < 0 && (a = u.length + a - 1), z.lineString([u[a], u[a + 1]], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a - 1), z.lineString([u[i][a], u[i][a + 1]], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a - 1), z.lineString([u[o][a], u[o][a + 1]], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a - 1), z.lineString([u[o][i][a], u[o][i][a + 1]], s, r) }throw new Error("geojson is invalid") }, r.findPoint = function (e, r) { if (r = r || {}, !z.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.coordIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": return z.point(u, s, r); case "MultiPoint": return o < 0 && (o = u.length + o), z.point(u[o], s, r); case "LineString": return a < 0 && (a = u.length + a), z.point(u[a], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a), z.point(u[i][a], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a), z.point(u[o][a], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a), z.point(u[o][i][a], s, r) }throw new Error("geojson is invalid") } }); c(D); D.coordEach, D.coordReduce, D.propEach, D.propReduce, D.featureEach, D.featureReduce, D.coordAll, D.geomEach, D.geomReduce, D.flattenEach, D.flattenReduce, D.segmentEach, D.segmentReduce, D.lineEach, D.lineReduce, D.findSegment, D.findPoint; var N = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function (e) { var r = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; return D.coordEach(e, function (e) { r[0] > e[0] && (r[0] = e[0]), r[1] > e[1] && (r[1] = e[1]), r[2] < e[0] && (r[2] = e[0]), r[3] < e[1] && (r[3] = e[1]) }), r } }); c(N); var B = N.default, G = I.featureEach, U = (I.coordEach, j.polygon, j.featureCollection); function q(e) { var r = w(e); return r.insert = function (e) { if ("Feature" !== e.type) throw new Error("invalid feature"); return e.bbox = e.bbox ? e.bbox : B(e), w.prototype.insert.call(this, e) }, r.load = function (e) { var r = []; return Array.isArray(e) ? e.forEach(function (e) { if ("Feature" !== e.type) throw new Error("invalid features"); e.bbox = e.bbox ? e.bbox : B(e), r.push(e) }) : G(e, function (e) { if ("Feature" !== e.type) throw new Error("invalid features"); e.bbox = e.bbox ? e.bbox : B(e), r.push(e) }), w.prototype.load.call(this, r) }, r.remove = function (e, r) { if ("Feature" !== e.type) throw new Error("invalid feature"); return e.bbox = e.bbox ? e.bbox : B(e), w.prototype.remove.call(this, e, r) }, r.clear = function () { return w.prototype.clear.call(this) }, r.search = function (e) { var r = w.prototype.search.call(this, this.toBBox(e)); return U(r) }, r.collides = function (e) { return w.prototype.collides.call(this, this.toBBox(e)) }, r.all = function () { var e = w.prototype.all.call(this); return U(e) }, r.toJSON = function () { return w.prototype.toJSON.call(this) }, r.fromJSON = function (e) { return w.prototype.fromJSON.call(this, e) }, r.toBBox = function (e) { var r; if (e.bbox) r = e.bbox; else if (Array.isArray(e) && 4 === e.length) r = e; else if (Array.isArray(e) && 6 === e.length) r = [e[0], e[1], e[3], e[4]]; else if ("Feature" === e.type) r = B(e); else { if ("FeatureCollection" !== e.type) throw new Error("invalid geojson"); r = B(e) } return { minX: r[0], minY: r[1], maxX: r[2], maxY: r[3] } }, r } var V = q, K = q; V.default = K; var H = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(H); H.earthRadius, H.factors, H.unitsFactors, H.areaFactors, H.feature, H.geometry, H.point, H.points, H.polygon, H.polygons, H.lineString, H.lineStrings, H.featureCollection, H.multiLineString, H.multiPoint, H.multiPolygon, H.geometryCollection, H.round, H.radiansToLength, H.lengthToRadians, H.lengthToDegrees, H.bearingToAzimuth, H.radiansToDegrees, H.degreesToRadians, H.convertLength, H.convertArea, H.isNumber, H.isObject, H.validateBBox, H.validateId, H.radians2degrees, H.degrees2radians, H.distanceToDegrees, H.distanceToRadians, H.radiansToDistance, H.bearingToAngle, H.convertDistance; var J = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.getCoord = function (e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && 2 <= e.length && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") }, r.getCoords = function (e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }, r.containsNumber = function e(r) { if (1 < r.length && H.isNumber(r[0]) && H.isNumber(r[1])) return !0; if (Array.isArray(r[0]) && r[0].length) return e(r[0]); throw new Error("coordinates must only contain numbers") }, r.geojsonType = function (e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) }, r.featureOf = function (e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) }, r.collectionOf = function (e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var n = 0, o = e.features; n < o.length; n++) { var i = o[n]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } }, r.getGeom = function (e) { return "Feature" === e.type ? e.geometry : e }, r.getType = function (e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } }); c(J); J.getCoord, J.getCoords, J.containsNumber, J.geojsonType, J.featureOf, J.collectionOf, J.getGeom, J.getType; var Y = g(function (e, r) { function P(e, r, t) { if (null !== e) for (var n, o, i, a, s, u, l, c, d = 0, g = 0, f = e.type, m = "FeatureCollection" === f, h = "Feature" === f, p = m ? e.features.length : 1, y = 0; y < p; y++) { s = (c = !!(l = m ? e.features[y].geometry : h ? e.geometry : e) && "GeometryCollection" === l.type) ? l.geometries.length : 1; for (var v = 0; v < s; v++) { var b = 0, w = 0; if (null !== (a = c ? l.geometries[v] : l)) { u = a.coordinates; var k = a.type; switch (d = !t || "Polygon" !== k && "MultiPolygon" !== k ? 0 : 1, k) { case null: break; case "Point": if (!1 === r(u, g, y, b, w)) return !1; g++, b++; break; case "LineString": case "MultiPoint": for (n = 0; n < u.length; n++) { if (!1 === r(u[n], g, y, b, w)) return !1; g++, "MultiPoint" === k && b++ } "LineString" === k && b++; break; case "Polygon": case "MultiLineString": for (n = 0; n < u.length; n++) { for (o = 0; o < u[n].length - d; o++) { if (!1 === r(u[n][o], g, y, b, w)) return !1; g++ } "MultiLineString" === k && b++, "Polygon" === k && w++ } "Polygon" === k && b++; break; case "MultiPolygon": for (n = 0; n < u.length; n++) { for (o = w = 0; o < u[n].length; o++) { for (i = 0; i < u[n][o].length - d; i++) { if (!1 === r(u[n][o][i], g, y, b, w)) return !1; g++ } w++ } b++ } break; case "GeometryCollection": for (n = 0; n < a.geometries.length; n++)if (!1 === P(a.geometries[n], r, t)) return !1; break; default: throw new Error("Unknown Geometry Type") } } } } } function i(e, r) { var t; switch (e.type) { case "FeatureCollection": for (t = 0; t < e.features.length && !1 !== r(e.features[t].properties, t); t++); break; case "Feature": r(e.properties, 0) } } function a(e, r) { if ("Feature" === e.type) r(e, 0); else if ("FeatureCollection" === e.type) for (var t = 0; t < e.features.length && !1 !== r(e.features[t], t); t++); } function t(e, r) { var t, n, o, i, a, s, u, l, c, d, g = 0, f = "FeatureCollection" === e.type, m = "Feature" === e.type, h = f ? e.features.length : 1; for (t = 0; t < h; t++) { for (s = f ? e.features[t].geometry : m ? e.geometry : e, l = f ? e.features[t].properties : m ? e.properties : {}, c = f ? e.features[t].bbox : m ? e.bbox : void 0, d = f ? e.features[t].id : m ? e.id : void 0, a = (u = !!s && "GeometryCollection" === s.type) ? s.geometries.length : 1, o = 0; o < a; o++)if (null !== (i = u ? s.geometries[o] : s)) switch (i.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === r(i, g, l, c, d)) return !1; break; case "GeometryCollection": for (n = 0; n < i.geometries.length; n++)if (!1 === r(i.geometries[n], g, l, c, d)) return !1; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === r(null, g, l, c, d)) return !1; g++ } } function s(e, l) { t(e, function (e, r, t, n, o) { var i, a = null === e ? null : e.type; switch (a) { case null: case "Point": case "LineString": case "Polygon": return !1 === l(H.feature(e, t, { bbox: n, id: o }), r, 0) ? !1 : void 0 }switch (a) { case "MultiPoint": i = "Point"; break; case "MultiLineString": i = "LineString"; break; case "MultiPolygon": i = "Polygon" }for (var s = 0; s < e.coordinates.length; s++) { var u = { type: i, coordinates: e.coordinates[s] }; if (!1 === l(H.feature(u, t), r, s)) return !1 } }) } function n(e, m) { s(e, function (a, s, u) { var l = 0; if (a.geometry) { var e = a.geometry.type; if ("Point" !== e && "MultiPoint" !== e) { var c, d = 0, g = 0, f = 0; return !1 !== P(a, function (e, r, t, n, o) { if (void 0 === c || d < s || g < n || f < o) return c = e, d = s, g = n, f = o, void (l = 0); var i = H.lineString([c, e], a.properties); if (!1 === m(i, s, u, o, l)) return !1; l++, c = e }) && void 0 } } }) } function u(e, a) { if (!e) throw new Error("geojson is required"); s(e, function (e, r, t) { if (null !== e.geometry) { var n = e.geometry.type, o = e.geometry.coordinates; switch (n) { case "LineString": if (!1 === a(e, r, t, 0, 0)) return !1; break; case "Polygon": for (var i = 0; i < o.length; i++)if (!1 === a(H.lineString(o[i], e.properties), r, t, i)) return !1 } } }) } Object.defineProperty(r, "__esModule", { value: !0 }), r.coordEach = P, r.coordReduce = function (e, i, a, r) { var s = a; return P(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }, r), s }, r.propEach = i, r.propReduce = function (e, t, n) { var o = n; return i(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.featureEach = a, r.featureReduce = function (e, t, n) { var o = n; return a(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.coordAll = function (e) { var r = []; return P(e, function (e) { r.push(e) }), r }, r.geomEach = t, r.geomReduce = function (e, i, a) { var s = a; return t(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }), s }, r.flattenEach = s, r.flattenReduce = function (e, n, o) { var i = o; return s(e, function (e, r, t) { i = 0 === r && 0 === t && void 0 === o ? e : n(i, e, r, t) }), i }, r.segmentEach = n, r.segmentReduce = function (e, i, a) { var s = a, u = !1; return n(e, function (e, r, t, n, o) { s = !1 === u && void 0 === a ? e : i(s, e, r, t, n, o), u = !0 }), s }, r.lineEach = u, r.lineReduce = function (e, o, i) { var a = i; return u(e, function (e, r, t, n) { a = 0 === r && void 0 === i ? e : o(a, e, r, t, n) }), a }, r.findSegment = function (e, r) { if (r = r || {}, !H.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.segmentIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": case "MultiPoint": return null; case "LineString": return a < 0 && (a = u.length + a - 1), H.lineString([u[a], u[a + 1]], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a - 1), H.lineString([u[i][a], u[i][a + 1]], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a - 1), H.lineString([u[o][a], u[o][a + 1]], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a - 1), H.lineString([u[o][i][a], u[o][i][a + 1]], s, r) }throw new Error("geojson is invalid") }, r.findPoint = function (e, r) { if (r = r || {}, !H.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.coordIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": return H.point(u, s, r); case "MultiPoint": return o < 0 && (o = u.length + o), H.point(u[o], s, r); case "LineString": return a < 0 && (a = u.length + a), H.point(u[a], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a), H.point(u[i][a], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a), H.point(u[o][a], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a), H.point(u[o][i][a], s, r) }throw new Error("geojson is invalid") } }); c(Y); Y.coordEach, Y.coordReduce, Y.propEach, Y.propReduce, Y.featureEach, Y.featureReduce, Y.coordAll, Y.geomEach, Y.geomReduce, Y.flattenEach, Y.flattenReduce, Y.segmentEach, Y.segmentReduce, Y.lineEach, Y.lineReduce, Y.findSegment, Y.findPoint; var W = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function (e) { if (!e) throw new Error("geojson is required"); var r = []; return Y.flattenEach(e, function (e) { !function (t, n) { var e = [], r = t.geometry; if (null !== r) { switch (r.type) { case "Polygon": e = J.getCoords(r); break; case "LineString": e = [J.getCoords(r)] }e.forEach(function (e) { var r, l, c; (r = e, l = t.properties, c = [], r.reduce(function (e, r) { var t, n, o, i, a, s, u = H.lineString([e, r], l); return u.bbox = (n = r, o = (t = e)[0], i = t[1], a = n[0], s = n[1], [o < a ? o : a, i < s ? i : s, a < o ? o : a, s < i ? i : s]), c.push(u), r }), c).forEach(function (e) { e.id = n.length, n.push(e) }) }) } }(e, r) }), H.featureCollection(r) } }); c(W); var X = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(X); X.earthRadius, X.factors, X.unitsFactors, X.areaFactors, X.feature, X.geometry, X.point, X.points, X.polygon, X.polygons, X.lineString, X.lineStrings, X.featureCollection, X.multiLineString, X.multiPoint, X.multiPolygon, X.geometryCollection, X.round, X.radiansToLength, X.lengthToRadians, X.lengthToDegrees, X.bearingToAzimuth, X.radiansToDegrees, X.degreesToRadians, X.convertLength, X.convertArea, X.isNumber, X.isObject, X.validateBBox, X.validateId, X.radians2degrees, X.degrees2radians, X.distanceToDegrees, X.distanceToRadians, X.radiansToDistance, X.bearingToAngle, X.convertDistance; var $ = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.getCoord = function (e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && 2 <= e.length && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") }, r.getCoords = function (e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }, r.containsNumber = function e(r) { if (1 < r.length && X.isNumber(r[0]) && X.isNumber(r[1])) return !0; if (Array.isArray(r[0]) && r[0].length) return e(r[0]); throw new Error("coordinates must only contain numbers") }, r.geojsonType = function (e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) }, r.featureOf = function (e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) }, r.collectionOf = function (e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var n = 0, o = e.features; n < o.length; n++) { var i = o[n]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } }, r.getGeom = function (e) { return "Feature" === e.type ? e.geometry : e }, r.getType = function (e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } }); c($); $.getCoord, $.getCoords, $.containsNumber, $.geojsonType, $.featureOf, $.collectionOf, $.getGeom, $.getType; var Z = g(function (e, r) { function d(e, r, t) { if (void 0 === t && (t = {}), !0 === t.final) return (d(r, e) + 180) % 360; var n = $.getCoord(e), o = $.getCoord(r), i = X.degreesToRadians(n[0]), a = X.degreesToRadians(o[0]), s = X.degreesToRadians(n[1]), u = X.degreesToRadians(o[1]), l = Math.sin(a - i) * Math.cos(u), c = Math.cos(s) * Math.sin(u) - Math.sin(s) * Math.cos(u) * Math.cos(a - i); return X.radiansToDegrees(Math.atan2(l, c)) } Object.defineProperty(r, "__esModule", { value: !0 }), r.default = d }); c(Z); var Q = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(Q); Q.earthRadius, Q.factors, Q.unitsFactors, Q.areaFactors, Q.feature, Q.geometry, Q.point, Q.points, Q.polygon, Q.polygons, Q.lineString, Q.lineStrings, Q.featureCollection, Q.multiLineString, Q.multiPoint, Q.multiPolygon, Q.geometryCollection, Q.round, Q.radiansToLength, Q.lengthToRadians, Q.lengthToDegrees, Q.bearingToAzimuth, Q.radiansToDegrees, Q.degreesToRadians, Q.convertLength, Q.convertArea, Q.isNumber, Q.isObject, Q.validateBBox, Q.validateId, Q.radians2degrees, Q.degrees2radians, Q.distanceToDegrees, Q.distanceToRadians, Q.radiansToDistance, Q.bearingToAngle, Q.convertDistance; var ee = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.getCoord = function (e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && 2 <= e.length && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") }, r.getCoords = function (e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }, r.containsNumber = function e(r) { if (1 < r.length && Q.isNumber(r[0]) && Q.isNumber(r[1])) return !0; if (Array.isArray(r[0]) && r[0].length) return e(r[0]); throw new Error("coordinates must only contain numbers") }, r.geojsonType = function (e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) }, r.featureOf = function (e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) }, r.collectionOf = function (e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var n = 0, o = e.features; n < o.length; n++) { var i = o[n]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } }, r.getGeom = function (e) { return "Feature" === e.type ? e.geometry : e }, r.getType = function (e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } }); c(ee); ee.getCoord, ee.getCoords, ee.containsNumber, ee.geojsonType, ee.featureOf, ee.collectionOf, ee.getGeom, ee.getType; var re = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function (e, r, t) { void 0 === t && (t = {}); var n = ee.getCoord(e), o = ee.getCoord(r), i = Q.degreesToRadians(o[1] - n[1]), a = Q.degreesToRadians(o[0] - n[0]), s = Q.degreesToRadians(n[1]), u = Q.degreesToRadians(o[1]), l = Math.pow(Math.sin(i / 2), 2) + Math.pow(Math.sin(a / 2), 2) * Math.cos(s) * Math.cos(u); return Q.radiansToLength(2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l)), t.units) } }); c(re); var te = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(te); te.earthRadius, te.factors, te.unitsFactors, te.areaFactors, te.feature, te.geometry, te.point, te.points, te.polygon, te.polygons, te.lineString, te.lineStrings, te.featureCollection, te.multiLineString, te.multiPoint, te.multiPolygon, te.geometryCollection, te.round, te.radiansToLength, te.lengthToRadians, te.lengthToDegrees, te.bearingToAzimuth, te.radiansToDegrees, te.degreesToRadians, te.convertLength, te.convertArea, te.isNumber, te.isObject, te.validateBBox, te.validateId, te.radians2degrees, te.degrees2radians, te.distanceToDegrees, te.distanceToRadians, te.radiansToDistance, te.bearingToAngle, te.convertDistance; var ne = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.getCoord = function (e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && 2 <= e.length && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") }, r.getCoords = function (e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }, r.containsNumber = function e(r) { if (1 < r.length && te.isNumber(r[0]) && te.isNumber(r[1])) return !0; if (Array.isArray(r[0]) && r[0].length) return e(r[0]); throw new Error("coordinates must only contain numbers") }, r.geojsonType = function (e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) }, r.featureOf = function (e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) }, r.collectionOf = function (e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var n = 0, o = e.features; n < o.length; n++) { var i = o[n]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } }, r.getGeom = function (e) { return "Feature" === e.type ? e.geometry : e }, r.getType = function (e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } }); c(ne); ne.getCoord, ne.getCoords, ne.containsNumber, ne.geojsonType, ne.featureOf, ne.collectionOf, ne.getGeom, ne.getType; var oe = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function (e, r, t, n) { void 0 === n && (n = {}); var o = ne.getCoord(e), i = te.degreesToRadians(o[0]), a = te.degreesToRadians(o[1]), s = te.degreesToRadians(t), u = te.lengthToRadians(r, n.units), l = Math.asin(Math.sin(a) * Math.cos(u) + Math.cos(a) * Math.sin(u) * Math.cos(s)), c = i + Math.atan2(Math.sin(s) * Math.sin(u) * Math.cos(a), Math.cos(u) - Math.sin(a) * Math.sin(l)), d = te.radiansToDegrees(c), g = te.radiansToDegrees(l); return te.point([d, g], n.properties) } }); c(oe); var ie = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(ie); ie.earthRadius, ie.factors, ie.unitsFactors, ie.areaFactors, ie.feature, ie.geometry, ie.point, ie.points, ie.polygon, ie.polygons, ie.lineString, ie.lineStrings, ie.featureCollection, ie.multiLineString, ie.multiPoint, ie.multiPolygon, ie.geometryCollection, ie.round, ie.radiansToLength, ie.lengthToRadians, ie.lengthToDegrees, ie.bearingToAzimuth, ie.radiansToDegrees, ie.degreesToRadians, ie.convertLength, ie.convertArea, ie.isNumber, ie.isObject, ie.validateBBox, ie.validateId, ie.radians2degrees, ie.degrees2radians, ie.distanceToDegrees, ie.distanceToRadians, ie.radiansToDistance, ie.bearingToAngle, ie.convertDistance; var ae = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.getCoord = function (e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && 2 <= e.length && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") }, r.getCoords = function (e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }, r.containsNumber = function e(r) { if (1 < r.length && ie.isNumber(r[0]) && ie.isNumber(r[1])) return !0; if (Array.isArray(r[0]) && r[0].length) return e(r[0]); throw new Error("coordinates must only contain numbers") }, r.geojsonType = function (e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) }, r.featureOf = function (e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) }, r.collectionOf = function (e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var n = 0, o = e.features; n < o.length; n++) { var i = o[n]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } }, r.getGeom = function (e) { return "Feature" === e.type ? e.geometry : e }, r.getType = function (e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } }); c(ae); ae.getCoord, ae.getCoords, ae.containsNumber, ae.geojsonType, ae.featureOf, ae.collectionOf, ae.getGeom, ae.getType; var se = g(function (e, r) { function P(e, r, t) { if (null !== e) for (var n, o, i, a, s, u, l, c, d = 0, g = 0, f = e.type, m = "FeatureCollection" === f, h = "Feature" === f, p = m ? e.features.length : 1, y = 0; y < p; y++) { s = (c = !!(l = m ? e.features[y].geometry : h ? e.geometry : e) && "GeometryCollection" === l.type) ? l.geometries.length : 1; for (var v = 0; v < s; v++) { var b = 0, w = 0; if (null !== (a = c ? l.geometries[v] : l)) { u = a.coordinates; var k = a.type; switch (d = !t || "Polygon" !== k && "MultiPolygon" !== k ? 0 : 1, k) { case null: break; case "Point": if (!1 === r(u, g, y, b, w)) return !1; g++, b++; break; case "LineString": case "MultiPoint": for (n = 0; n < u.length; n++) { if (!1 === r(u[n], g, y, b, w)) return !1; g++, "MultiPoint" === k && b++ } "LineString" === k && b++; break; case "Polygon": case "MultiLineString": for (n = 0; n < u.length; n++) { for (o = 0; o < u[n].length - d; o++) { if (!1 === r(u[n][o], g, y, b, w)) return !1; g++ } "MultiLineString" === k && b++, "Polygon" === k && w++ } "Polygon" === k && b++; break; case "MultiPolygon": for (n = 0; n < u.length; n++) { for (o = w = 0; o < u[n].length; o++) { for (i = 0; i < u[n][o].length - d; i++) { if (!1 === r(u[n][o][i], g, y, b, w)) return !1; g++ } w++ } b++ } break; case "GeometryCollection": for (n = 0; n < a.geometries.length; n++)if (!1 === P(a.geometries[n], r, t)) return !1; break; default: throw new Error("Unknown Geometry Type") } } } } } function i(e, r) { var t; switch (e.type) { case "FeatureCollection": for (t = 0; t < e.features.length && !1 !== r(e.features[t].properties, t); t++); break; case "Feature": r(e.properties, 0) } } function a(e, r) { if ("Feature" === e.type) r(e, 0); else if ("FeatureCollection" === e.type) for (var t = 0; t < e.features.length && !1 !== r(e.features[t], t); t++); } function t(e, r) { var t, n, o, i, a, s, u, l, c, d, g = 0, f = "FeatureCollection" === e.type, m = "Feature" === e.type, h = f ? e.features.length : 1; for (t = 0; t < h; t++) { for (s = f ? e.features[t].geometry : m ? e.geometry : e, l = f ? e.features[t].properties : m ? e.properties : {}, c = f ? e.features[t].bbox : m ? e.bbox : void 0, d = f ? e.features[t].id : m ? e.id : void 0, a = (u = !!s && "GeometryCollection" === s.type) ? s.geometries.length : 1, o = 0; o < a; o++)if (null !== (i = u ? s.geometries[o] : s)) switch (i.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === r(i, g, l, c, d)) return !1; break; case "GeometryCollection": for (n = 0; n < i.geometries.length; n++)if (!1 === r(i.geometries[n], g, l, c, d)) return !1; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === r(null, g, l, c, d)) return !1; g++ } } function s(e, l) { t(e, function (e, r, t, n, o) { var i, a = null === e ? null : e.type; switch (a) { case null: case "Point": case "LineString": case "Polygon": return !1 === l(ie.feature(e, t, { bbox: n, id: o }), r, 0) ? !1 : void 0 }switch (a) { case "MultiPoint": i = "Point"; break; case "MultiLineString": i = "LineString"; break; case "MultiPolygon": i = "Polygon" }for (var s = 0; s < e.coordinates.length; s++) { var u = { type: i, coordinates: e.coordinates[s] }; if (!1 === l(ie.feature(u, t), r, s)) return !1 } }) } function n(e, m) { s(e, function (a, s, u) { var l = 0; if (a.geometry) { var e = a.geometry.type; if ("Point" !== e && "MultiPoint" !== e) { var c, d = 0, g = 0, f = 0; return !1 !== P(a, function (e, r, t, n, o) { if (void 0 === c || d < s || g < n || f < o) return c = e, d = s, g = n, f = o, void (l = 0); var i = ie.lineString([c, e], a.properties); if (!1 === m(i, s, u, o, l)) return !1; l++, c = e }) && void 0 } } }) } function u(e, a) { if (!e) throw new Error("geojson is required"); s(e, function (e, r, t) { if (null !== e.geometry) { var n = e.geometry.type, o = e.geometry.coordinates; switch (n) { case "LineString": if (!1 === a(e, r, t, 0, 0)) return !1; break; case "Polygon": for (var i = 0; i < o.length; i++)if (!1 === a(ie.lineString(o[i], e.properties), r, t, i)) return !1 } } }) } Object.defineProperty(r, "__esModule", { value: !0 }), r.coordEach = P, r.coordReduce = function (e, i, a, r) { var s = a; return P(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }, r), s }, r.propEach = i, r.propReduce = function (e, t, n) { var o = n; return i(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.featureEach = a, r.featureReduce = function (e, t, n) { var o = n; return a(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.coordAll = function (e) { var r = []; return P(e, function (e) { r.push(e) }), r }, r.geomEach = t, r.geomReduce = function (e, i, a) { var s = a; return t(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }), s }, r.flattenEach = s, r.flattenReduce = function (e, n, o) { var i = o; return s(e, function (e, r, t) { i = 0 === r && 0 === t && void 0 === o ? e : n(i, e, r, t) }), i }, r.segmentEach = n, r.segmentReduce = function (e, i, a) { var s = a, u = !1; return n(e, function (e, r, t, n, o) { s = !1 === u && void 0 === a ? e : i(s, e, r, t, n, o), u = !0 }), s }, r.lineEach = u, r.lineReduce = function (e, o, i) { var a = i; return u(e, function (e, r, t, n) { a = 0 === r && void 0 === i ? e : o(a, e, r, t, n) }), a }, r.findSegment = function (e, r) { if (r = r || {}, !ie.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.segmentIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": case "MultiPoint": return null; case "LineString": return a < 0 && (a = u.length + a - 1), ie.lineString([u[a], u[a + 1]], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a - 1), ie.lineString([u[i][a], u[i][a + 1]], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a - 1), ie.lineString([u[o][a], u[o][a + 1]], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a - 1), ie.lineString([u[o][i][a], u[o][i][a + 1]], s, r) }throw new Error("geojson is invalid") }, r.findPoint = function (e, r) { if (r = r || {}, !ie.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.coordIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": return ie.point(u, s, r); case "MultiPoint": return o < 0 && (o = u.length + o), ie.point(u[o], s, r); case "LineString": return a < 0 && (a = u.length + a), ie.point(u[a], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a), ie.point(u[i][a], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a), ie.point(u[o][a], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a), ie.point(u[o][i][a], s, r) }throw new Error("geojson is invalid") } }); c(se); se.coordEach, se.coordReduce, se.propEach, se.propReduce, se.featureEach, se.featureReduce, se.coordAll, se.geomEach, se.geomReduce, se.flattenEach, se.flattenReduce, se.segmentEach, se.segmentReduce, se.lineEach, se.lineReduce, se.findSegment, se.findPoint; var ue = g(function (e, r) { var t = b && b.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(r, "__esModule", { value: !0 }); var n = t(W), s = t(V); function u(e, r) { var t = ae.getCoords(e), n = ae.getCoords(r); if (2 !== t.length) throw new Error("<intersects> line1 must only contain 2 coordinates"); if (2 !== n.length) throw new Error("<intersects> line2 must only contain 2 coordinates"); var o = t[0][0], i = t[0][1], a = t[1][0], s = t[1][1], u = n[0][0], l = n[0][1], c = n[1][0], d = n[1][1], g = (d - l) * (a - o) - (c - u) * (s - i); if (0 == g) return null; var f = ((c - u) * (i - l) - (d - l) * (o - u)) / g, m = ((a - o) * (i - l) - (s - i) * (o - u)) / g; if (0 <= f && f <= 1 && 0 <= m && m <= 1) { var h = o + f * (a - o), p = i + f * (s - i); return ie.point([h, p]) } return null } r.default = function (e, r) { var o = {}, i = []; if ("LineString" === e.type && (e = ie.feature(e)), "LineString" === r.type && (r = ie.feature(r)), "Feature" === e.type && "Feature" === r.type && null !== e.geometry && null !== r.geometry && "LineString" === e.geometry.type && "LineString" === r.geometry.type && 2 === e.geometry.coordinates.length && 2 === r.geometry.coordinates.length) { var t = u(e, r); return t && i.push(t), ie.featureCollection(i) } var a = s.default(); return a.load(n.default(r)), se.featureEach(n.default(e), function (n) { se.featureEach(a.search(n), function (e) { var r = u(n, e); if (r) { var t = ae.getCoords(r).join(","); o[t] || (o[t] = !0, i.push(r)) } }) }), ie.featureCollection(i) } }); c(ue); var le = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(le); le.earthRadius, le.factors, le.unitsFactors, le.areaFactors, le.feature, le.geometry, le.point, le.points, le.polygon, le.polygons, le.lineString, le.lineStrings, le.featureCollection, le.multiLineString, le.multiPoint, le.multiPolygon, le.geometryCollection, le.round, le.radiansToLength, le.lengthToRadians, le.lengthToDegrees, le.bearingToAzimuth, le.radiansToDegrees, le.degreesToRadians, le.convertLength, le.convertArea, le.isNumber, le.isObject, le.validateBBox, le.validateId, le.radians2degrees, le.degrees2radians, le.distanceToDegrees, le.distanceToRadians, le.radiansToDistance, le.bearingToAngle, le.convertDistance; var ce = g(function (e, r) { function P(e, r, t) { if (null !== e) for (var n, o, i, a, s, u, l, c, d = 0, g = 0, f = e.type, m = "FeatureCollection" === f, h = "Feature" === f, p = m ? e.features.length : 1, y = 0; y < p; y++) { s = (c = !!(l = m ? e.features[y].geometry : h ? e.geometry : e) && "GeometryCollection" === l.type) ? l.geometries.length : 1; for (var v = 0; v < s; v++) { var b = 0, w = 0; if (null !== (a = c ? l.geometries[v] : l)) { u = a.coordinates; var k = a.type; switch (d = !t || "Polygon" !== k && "MultiPolygon" !== k ? 0 : 1, k) { case null: break; case "Point": if (!1 === r(u, g, y, b, w)) return !1; g++, b++; break; case "LineString": case "MultiPoint": for (n = 0; n < u.length; n++) { if (!1 === r(u[n], g, y, b, w)) return !1; g++, "MultiPoint" === k && b++ } "LineString" === k && b++; break; case "Polygon": case "MultiLineString": for (n = 0; n < u.length; n++) { for (o = 0; o < u[n].length - d; o++) { if (!1 === r(u[n][o], g, y, b, w)) return !1; g++ } "MultiLineString" === k && b++, "Polygon" === k && w++ } "Polygon" === k && b++; break; case "MultiPolygon": for (n = 0; n < u.length; n++) { for (o = w = 0; o < u[n].length; o++) { for (i = 0; i < u[n][o].length - d; i++) { if (!1 === r(u[n][o][i], g, y, b, w)) return !1; g++ } w++ } b++ } break; case "GeometryCollection": for (n = 0; n < a.geometries.length; n++)if (!1 === P(a.geometries[n], r, t)) return !1; break; default: throw new Error("Unknown Geometry Type") } } } } } function i(e, r) { var t; switch (e.type) { case "FeatureCollection": for (t = 0; t < e.features.length && !1 !== r(e.features[t].properties, t); t++); break; case "Feature": r(e.properties, 0) } } function a(e, r) { if ("Feature" === e.type) r(e, 0); else if ("FeatureCollection" === e.type) for (var t = 0; t < e.features.length && !1 !== r(e.features[t], t); t++); } function t(e, r) { var t, n, o, i, a, s, u, l, c, d, g = 0, f = "FeatureCollection" === e.type, m = "Feature" === e.type, h = f ? e.features.length : 1; for (t = 0; t < h; t++) { for (s = f ? e.features[t].geometry : m ? e.geometry : e, l = f ? e.features[t].properties : m ? e.properties : {}, c = f ? e.features[t].bbox : m ? e.bbox : void 0, d = f ? e.features[t].id : m ? e.id : void 0, a = (u = !!s && "GeometryCollection" === s.type) ? s.geometries.length : 1, o = 0; o < a; o++)if (null !== (i = u ? s.geometries[o] : s)) switch (i.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === r(i, g, l, c, d)) return !1; break; case "GeometryCollection": for (n = 0; n < i.geometries.length; n++)if (!1 === r(i.geometries[n], g, l, c, d)) return !1; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === r(null, g, l, c, d)) return !1; g++ } } function s(e, l) { t(e, function (e, r, t, n, o) { var i, a = null === e ? null : e.type; switch (a) { case null: case "Point": case "LineString": case "Polygon": return !1 === l(le.feature(e, t, { bbox: n, id: o }), r, 0) ? !1 : void 0 }switch (a) { case "MultiPoint": i = "Point"; break; case "MultiLineString": i = "LineString"; break; case "MultiPolygon": i = "Polygon" }for (var s = 0; s < e.coordinates.length; s++) { var u = { type: i, coordinates: e.coordinates[s] }; if (!1 === l(le.feature(u, t), r, s)) return !1 } }) } function n(e, m) { s(e, function (a, s, u) { var l = 0; if (a.geometry) { var e = a.geometry.type; if ("Point" !== e && "MultiPoint" !== e) { var c, d = 0, g = 0, f = 0; return !1 !== P(a, function (e, r, t, n, o) { if (void 0 === c || d < s || g < n || f < o) return c = e, d = s, g = n, f = o, void (l = 0); var i = le.lineString([c, e], a.properties); if (!1 === m(i, s, u, o, l)) return !1; l++, c = e }) && void 0 } } }) } function u(e, a) { if (!e) throw new Error("geojson is required"); s(e, function (e, r, t) { if (null !== e.geometry) { var n = e.geometry.type, o = e.geometry.coordinates; switch (n) { case "LineString": if (!1 === a(e, r, t, 0, 0)) return !1; break; case "Polygon": for (var i = 0; i < o.length; i++)if (!1 === a(le.lineString(o[i], e.properties), r, t, i)) return !1 } } }) } Object.defineProperty(r, "__esModule", { value: !0 }), r.coordEach = P, r.coordReduce = function (e, i, a, r) { var s = a; return P(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }, r), s }, r.propEach = i, r.propReduce = function (e, t, n) { var o = n; return i(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.featureEach = a, r.featureReduce = function (e, t, n) { var o = n; return a(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.coordAll = function (e) { var r = []; return P(e, function (e) { r.push(e) }), r }, r.geomEach = t, r.geomReduce = function (e, i, a) { var s = a; return t(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }), s }, r.flattenEach = s, r.flattenReduce = function (e, n, o) { var i = o; return s(e, function (e, r, t) { i = 0 === r && 0 === t && void 0 === o ? e : n(i, e, r, t) }), i }, r.segmentEach = n, r.segmentReduce = function (e, i, a) { var s = a, u = !1; return n(e, function (e, r, t, n, o) { s = !1 === u && void 0 === a ? e : i(s, e, r, t, n, o), u = !0 }), s }, r.lineEach = u, r.lineReduce = function (e, o, i) { var a = i; return u(e, function (e, r, t, n) { a = 0 === r && void 0 === i ? e : o(a, e, r, t, n) }), a }, r.findSegment = function (e, r) { if (r = r || {}, !le.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.segmentIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": case "MultiPoint": return null; case "LineString": return a < 0 && (a = u.length + a - 1), le.lineString([u[a], u[a + 1]], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a - 1), le.lineString([u[i][a], u[i][a + 1]], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a - 1), le.lineString([u[o][a], u[o][a + 1]], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a - 1), le.lineString([u[o][i][a], u[o][i][a + 1]], s, r) }throw new Error("geojson is invalid") }, r.findPoint = function (e, r) { if (r = r || {}, !le.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.coordIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": return le.point(u, s, r); case "MultiPoint": return o < 0 && (o = u.length + o), le.point(u[o], s, r); case "LineString": return a < 0 && (a = u.length + a), le.point(u[a], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a), le.point(u[i][a], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a), le.point(u[o][a], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a), le.point(u[o][i][a], s, r) }throw new Error("geojson is invalid") } }); c(ce); ce.coordEach, ce.coordReduce, ce.propEach, ce.propReduce, ce.featureEach, ce.featureReduce, ce.coordAll, ce.geomEach, ce.geomReduce, ce.flattenEach, ce.flattenReduce, ce.segmentEach, ce.segmentReduce, ce.lineEach, ce.lineReduce, ce.findSegment, ce.findPoint; var de = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.getCoord = function (e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && 2 <= e.length && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") }, r.getCoords = function (e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }, r.containsNumber = function e(r) { if (1 < r.length && le.isNumber(r[0]) && le.isNumber(r[1])) return !0; if (Array.isArray(r[0]) && r[0].length) return e(r[0]); throw new Error("coordinates must only contain numbers") }, r.geojsonType = function (e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) }, r.featureOf = function (e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) }, r.collectionOf = function (e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var n = 0, o = e.features; n < o.length; n++) { var i = o[n]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } }, r.getGeom = function (e) { return "Feature" === e.type ? e.geometry : e }, r.getType = function (e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } }); c(de); de.getCoord, de.getCoords, de.containsNumber, de.geojsonType, de.featureOf, de.collectionOf, de.getGeom, de.getType; var ge = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function (e, g, f) { void 0 === f && (f = {}); var m = le.point([1 / 0, 1 / 0], { dist: 1 / 0 }), h = 0; return ce.flattenEach(e, function (e) { for (var r = de.getCoords(e), t = 0; t < r.length - 1; t++) { var n = le.point(r[t]); n.properties.dist = re.default(g, n, f); var o = le.point(r[t + 1]); o.properties.dist = re.default(g, o, f); var i = re.default(n, o, f), a = Math.max(n.properties.dist, o.properties.dist), s = Z.default(n, o), u = oe.default(g, a, s + 90, f), l = oe.default(g, a, s - 90, f), c = ue.default(le.lineString([u.geometry.coordinates, l.geometry.coordinates]), le.lineString([n.geometry.coordinates, o.geometry.coordinates])), d = null; 0 < c.features.length && ((d = c.features[0]).properties.dist = re.default(g, d, f), d.properties.location = h + re.default(n, d, f)), n.properties.dist < m.properties.dist && ((m = n).properties.index = t, m.properties.location = h), o.properties.dist < m.properties.dist && ((m = o).properties.index = t + 1, m.properties.location = h + i), d && d.properties.dist < m.properties.dist && ((m = d).properties.index = t), h += i } }), m } }); c(ge); var fe = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(fe); fe.earthRadius, fe.factors, fe.unitsFactors, fe.areaFactors, fe.feature, fe.geometry, fe.point, fe.points, fe.polygon, fe.polygons, fe.lineString, fe.lineStrings, fe.featureCollection, fe.multiLineString, fe.multiPoint, fe.multiPolygon, fe.geometryCollection, fe.round, fe.radiansToLength, fe.lengthToRadians, fe.lengthToDegrees, fe.bearingToAzimuth, fe.radiansToDegrees, fe.degreesToRadians, fe.convertLength, fe.convertArea, fe.isNumber, fe.isObject, fe.validateBBox, fe.validateId, fe.radians2degrees, fe.degrees2radians, fe.distanceToDegrees, fe.distanceToRadians, fe.radiansToDistance, fe.bearingToAngle, fe.convertDistance; var me = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.getCoord = function (e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && 2 <= e.length && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") }, r.getCoords = function (e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }, r.containsNumber = function e(r) { if (1 < r.length && fe.isNumber(r[0]) && fe.isNumber(r[1])) return !0; if (Array.isArray(r[0]) && r[0].length) return e(r[0]); throw new Error("coordinates must only contain numbers") }, r.geojsonType = function (e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) }, r.featureOf = function (e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) }, r.collectionOf = function (e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var n = 0, o = e.features; n < o.length; n++) { var i = o[n]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } }, r.getGeom = function (e) { return "Feature" === e.type ? e.geometry : e }, r.getType = function (e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } }); c(me); me.getCoord, me.getCoords, me.containsNumber, me.geojsonType, me.featureOf, me.collectionOf, me.getGeom, me.getType; var he = g(function (e, r) { function s(e, r, t, n) { var o = t[0], i = t[1], a = e[0], s = e[1], u = r[0], l = r[1], c = u - a, d = l - s; return 0 == (t[0] - a) * d - (t[1] - s) * c && (n ? "start" === n ? Math.abs(c) >= Math.abs(d) ? 0 < c ? a < o && o <= u : u <= o && o < a : 0 < d ? s < i && i <= l : l <= i && i < s : "end" === n ? Math.abs(c) >= Math.abs(d) ? 0 < c ? a <= o && o < u : u < o && o <= a : 0 < d ? s <= i && i < l : l < i && i <= s : "both" === n && (Math.abs(c) >= Math.abs(d) ? 0 < c ? a < o && o < u : u < o && o < a : 0 < d ? s < i && i < l : l < i && i < s) : Math.abs(c) >= Math.abs(d) ? 0 < c ? a <= o && o <= u : u <= o && o <= a : 0 < d ? s <= i && i <= l : l <= i && i <= s) } Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function (e, r, t) { void 0 === t && (t = {}); for (var n = me.getCoord(e), o = me.getCoords(r), i = 0; i < o.length - 1; i++) { var a = !1; if (t.ignoreEndVertices && (0 === i && (a = "start"), i === o.length - 2 && (a = "end"), 0 === i && i + 1 === o.length - 1 && (a = "both")), s(o[i], o[i + 1], n, a)) return !0 } return !1 } }); c(he); var pe = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(pe); pe.earthRadius, pe.factors, pe.unitsFactors, pe.areaFactors, pe.feature, pe.geometry, pe.point, pe.points, pe.polygon, pe.polygons, pe.lineString, pe.lineStrings, pe.featureCollection, pe.multiLineString, pe.multiPoint, pe.multiPolygon, pe.geometryCollection, pe.round, pe.radiansToLength, pe.lengthToRadians, pe.lengthToDegrees, pe.bearingToAzimuth, pe.radiansToDegrees, pe.degreesToRadians, pe.convertLength, pe.convertArea, pe.isNumber, pe.isObject, pe.validateBBox, pe.validateId, pe.radians2degrees, pe.degrees2radians, pe.distanceToDegrees, pe.distanceToRadians, pe.radiansToDistance, pe.bearingToAngle, pe.convertDistance; var ye = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.getCoord = function (e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && 2 <= e.length && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") }, r.getCoords = function (e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }, r.containsNumber = function e(r) { if (1 < r.length && pe.isNumber(r[0]) && pe.isNumber(r[1])) return !0; if (Array.isArray(r[0]) && r[0].length) return e(r[0]); throw new Error("coordinates must only contain numbers") }, r.geojsonType = function (e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) }, r.featureOf = function (e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) }, r.collectionOf = function (e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var n = 0, o = e.features; n < o.length; n++) { var i = o[n]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } }, r.getGeom = function (e) { return "Feature" === e.type ? e.geometry : e }, r.getType = function (e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } }); c(ye); ye.getCoord, ye.getCoords, ye.containsNumber, ye.geojsonType, ye.featureOf, ye.collectionOf, ye.getGeom, ye.getType; var ve = g(function (e, r) { function P(e, r, t) { if (null !== e) for (var n, o, i, a, s, u, l, c, d = 0, g = 0, f = e.type, m = "FeatureCollection" === f, h = "Feature" === f, p = m ? e.features.length : 1, y = 0; y < p; y++) { s = (c = !!(l = m ? e.features[y].geometry : h ? e.geometry : e) && "GeometryCollection" === l.type) ? l.geometries.length : 1; for (var v = 0; v < s; v++) { var b = 0, w = 0; if (null !== (a = c ? l.geometries[v] : l)) { u = a.coordinates; var k = a.type; switch (d = !t || "Polygon" !== k && "MultiPolygon" !== k ? 0 : 1, k) { case null: break; case "Point": if (!1 === r(u, g, y, b, w)) return !1; g++, b++; break; case "LineString": case "MultiPoint": for (n = 0; n < u.length; n++) { if (!1 === r(u[n], g, y, b, w)) return !1; g++, "MultiPoint" === k && b++ } "LineString" === k && b++; break; case "Polygon": case "MultiLineString": for (n = 0; n < u.length; n++) { for (o = 0; o < u[n].length - d; o++) { if (!1 === r(u[n][o], g, y, b, w)) return !1; g++ } "MultiLineString" === k && b++, "Polygon" === k && w++ } "Polygon" === k && b++; break; case "MultiPolygon": for (n = 0; n < u.length; n++) { for (o = w = 0; o < u[n].length; o++) { for (i = 0; i < u[n][o].length - d; i++) { if (!1 === r(u[n][o][i], g, y, b, w)) return !1; g++ } w++ } b++ } break; case "GeometryCollection": for (n = 0; n < a.geometries.length; n++)if (!1 === P(a.geometries[n], r, t)) return !1; break; default: throw new Error("Unknown Geometry Type") } } } } } function i(e, r) { var t; switch (e.type) { case "FeatureCollection": for (t = 0; t < e.features.length && !1 !== r(e.features[t].properties, t); t++); break; case "Feature": r(e.properties, 0) } } function a(e, r) { if ("Feature" === e.type) r(e, 0); else if ("FeatureCollection" === e.type) for (var t = 0; t < e.features.length && !1 !== r(e.features[t], t); t++); } function t(e, r) { var t, n, o, i, a, s, u, l, c, d, g = 0, f = "FeatureCollection" === e.type, m = "Feature" === e.type, h = f ? e.features.length : 1; for (t = 0; t < h; t++) { for (s = f ? e.features[t].geometry : m ? e.geometry : e, l = f ? e.features[t].properties : m ? e.properties : {}, c = f ? e.features[t].bbox : m ? e.bbox : void 0, d = f ? e.features[t].id : m ? e.id : void 0, a = (u = !!s && "GeometryCollection" === s.type) ? s.geometries.length : 1, o = 0; o < a; o++)if (null !== (i = u ? s.geometries[o] : s)) switch (i.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === r(i, g, l, c, d)) return !1; break; case "GeometryCollection": for (n = 0; n < i.geometries.length; n++)if (!1 === r(i.geometries[n], g, l, c, d)) return !1; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === r(null, g, l, c, d)) return !1; g++ } } function s(e, l) { t(e, function (e, r, t, n, o) { var i, a = null === e ? null : e.type; switch (a) { case null: case "Point": case "LineString": case "Polygon": return !1 === l(pe.feature(e, t, { bbox: n, id: o }), r, 0) ? !1 : void 0 }switch (a) { case "MultiPoint": i = "Point"; break; case "MultiLineString": i = "LineString"; break; case "MultiPolygon": i = "Polygon" }for (var s = 0; s < e.coordinates.length; s++) { var u = { type: i, coordinates: e.coordinates[s] }; if (!1 === l(pe.feature(u, t), r, s)) return !1 } }) } function n(e, m) { s(e, function (a, s, u) { var l = 0; if (a.geometry) { var e = a.geometry.type; if ("Point" !== e && "MultiPoint" !== e) { var c, d = 0, g = 0, f = 0; return !1 !== P(a, function (e, r, t, n, o) { if (void 0 === c || d < s || g < n || f < o) return c = e, d = s, g = n, f = o, void (l = 0); var i = pe.lineString([c, e], a.properties); if (!1 === m(i, s, u, o, l)) return !1; l++, c = e }) && void 0 } } }) } function u(e, a) { if (!e) throw new Error("geojson is required"); s(e, function (e, r, t) { if (null !== e.geometry) { var n = e.geometry.type, o = e.geometry.coordinates; switch (n) { case "LineString": if (!1 === a(e, r, t, 0, 0)) return !1; break; case "Polygon": for (var i = 0; i < o.length; i++)if (!1 === a(pe.lineString(o[i], e.properties), r, t, i)) return !1 } } }) } Object.defineProperty(r, "__esModule", { value: !0 }), r.coordEach = P, r.coordReduce = function (e, i, a, r) { var s = a; return P(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }, r), s }, r.propEach = i, r.propReduce = function (e, t, n) { var o = n; return i(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.featureEach = a, r.featureReduce = function (e, t, n) { var o = n; return a(e, function (e, r) { o = 0 === r && void 0 === n ? e : t(o, e, r) }), o }, r.coordAll = function (e) { var r = []; return P(e, function (e) { r.push(e) }), r }, r.geomEach = t, r.geomReduce = function (e, i, a) { var s = a; return t(e, function (e, r, t, n, o) { s = 0 === r && void 0 === a ? e : i(s, e, r, t, n, o) }), s }, r.flattenEach = s, r.flattenReduce = function (e, n, o) { var i = o; return s(e, function (e, r, t) { i = 0 === r && 0 === t && void 0 === o ? e : n(i, e, r, t) }), i }, r.segmentEach = n, r.segmentReduce = function (e, i, a) { var s = a, u = !1; return n(e, function (e, r, t, n, o) { s = !1 === u && void 0 === a ? e : i(s, e, r, t, n, o), u = !0 }), s }, r.lineEach = u, r.lineReduce = function (e, o, i) { var a = i; return u(e, function (e, r, t, n) { a = 0 === r && void 0 === i ? e : o(a, e, r, t, n) }), a }, r.findSegment = function (e, r) { if (r = r || {}, !pe.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.segmentIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": case "MultiPoint": return null; case "LineString": return a < 0 && (a = u.length + a - 1), pe.lineString([u[a], u[a + 1]], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a - 1), pe.lineString([u[i][a], u[i][a + 1]], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a - 1), pe.lineString([u[o][a], u[o][a + 1]], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a - 1), pe.lineString([u[o][i][a], u[o][i][a + 1]], s, r) }throw new Error("geojson is invalid") }, r.findPoint = function (e, r) { if (r = r || {}, !pe.isObject(r)) throw new Error("options is invalid"); var t, n = r.featureIndex || 0, o = r.multiFeatureIndex || 0, i = r.geometryIndex || 0, a = r.coordIndex || 0, s = r.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), s = s || e.features[n].properties, t = e.features[n].geometry; break; case "Feature": s = s || e.properties, t = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": t = e; break; default: throw new Error("geojson is invalid") }if (null === t) return null; var u = t.coordinates; switch (t.type) { case "Point": return pe.point(u, s, r); case "MultiPoint": return o < 0 && (o = u.length + o), pe.point(u[o], s, r); case "LineString": return a < 0 && (a = u.length + a), pe.point(u[a], s, r); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a), pe.point(u[i][a], s, r); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a), pe.point(u[o][a], s, r); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a), pe.point(u[o][i][a], s, r) }throw new Error("geojson is invalid") } }); c(ve); ve.coordEach, ve.coordReduce, ve.propEach, ve.propReduce, ve.featureEach, ve.featureReduce, ve.coordAll, ve.geomEach, ve.geomReduce, ve.flattenEach, ve.flattenReduce, ve.segmentEach, ve.segmentReduce, ve.lineEach, ve.lineReduce, ve.findSegment, ve.findPoint; function be(e) { var r = ke.call(e), t = "[object Arguments]" === r; return t = t || "[object Array]" !== r && null !== e && "object" == typeof e && "number" == typeof e.length && 0 <= e.length && "[object Function]" === ke.call(e.callee) } var we, ke = Object.prototype.toString; if (!Object.keys) { var Pe = Object.prototype.hasOwnProperty, Ee = Object.prototype.toString, Se = be, Te = Object.prototype.propertyIsEnumerable, Me = !Te.call({ toString: null }, "toString"), Ae = Te.call(function () { }, "prototype"), Re = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], Ce = function (e) { var r = e.constructor; return r && r.prototype === e }, xe = { $applicationCache: !0, $console: !0, $external: !0, $frame: !0, $frameElement: !0, $frames: !0, $innerHeight: !0, $innerWidth: !0, $onmozfullscreenchange: !0, $onmozfullscreenerror: !0, $outerHeight: !0, $outerWidth: !0, $pageXOffset: !0, $pageYOffset: !0, $parent: !0, $scrollLeft: !0, $scrollTop: !0, $scrollX: !0, $scrollY: !0, $self: !0, $webkitIndexedDB: !0, $webkitStorageInfo: !0, $window: !0 }, Fe = function () { if ("undefined" == typeof window) return !1; for (var e in window) try { if (!xe["$" + e] && Pe.call(window, e) && null !== window[e] && "object" == typeof window[e]) try { Ce(window[e]) } catch (e) { return !0 } } catch (e) { return !0 } return !1 }(); we = function (e) { var r = null !== e && "object" == typeof e, t = "[object Function]" === Ee.call(e), n = Se(e), o = r && "[object String]" === Ee.call(e), i = []; if (!r && !t && !n) throw new TypeError("Object.keys called on a non-object"); var a = Ae && t; if (o && 0 < e.length && !Pe.call(e, 0)) for (var s = 0; s < e.length; ++s)i.push(String(s)); if (n && 0 < e.length) for (var u = 0; u < e.length; ++u)i.push(String(u)); else for (var l in e) a && "prototype" === l || !Pe.call(e, l) || i.push(String(l)); if (Me) for (var c = function (e) { if ("undefined" == typeof window || !Fe) return Ce(e); try { return Ce(e) } catch (e) { return !1 } }(e), d = 0; d < Re.length; ++d)c && "constructor" === Re[d] || !Pe.call(e, Re[d]) || i.push(Re[d]); return i } } var Oe = we, Le = Array.prototype.slice, _e = Object.keys, je = _e ? function (e) { return _e(e) } : Oe, Ie = Object.keys; je.shim = function () { Object.keys ? function () { var e = Object.keys(arguments); return e && e.length === arguments.length }(1, 2) || (Object.keys = function (e) { return be(e) ? Ie(Le.call(e)) : Ie(e) }) : Object.keys = je; return Object.keys || je }; function ze(e) { return !(Be && e && "object" == typeof e && Symbol.toStringTag in e) && "[object Arguments]" === Ge.call(e) } function De(e) { return !!ze(e) || null !== e && "object" == typeof e && "number" == typeof e.length && 0 <= e.length && "[object Array]" !== Ge.call(e) && "[object Function]" === Ge.call(e.callee) } var Ne = je, Be = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, Ge = Object.prototype.toString, Ue = function () { return ze(arguments) }(); ze.isLegacyArguments = De; function qe(e, r, t, n) { var o; r in e && ("function" != typeof (o = n) || "[object Function]" !== Je.call(o) || !n()) || (Xe ? We(e, r, { configurable: !0, enumerable: !1, value: t, writable: !0 }) : e[r] = t) } function Ve(e, r) { var t = 2 < arguments.length ? arguments[2] : {}, n = Ne(r); He && (n = Ye.call(n, Object.getOwnPropertySymbols(r))); for (var o = 0; o < n.length; o += 1)qe(e, n[o], r[n[o]], t[n[o]]) } var Ke = Ue ? ze : De, He = "function" == typeof Symbol && "symbol" == typeof Symbol("foo"), Je = Object.prototype.toString, Ye = Array.prototype.concat, We = Object.defineProperty, Xe = We && function () { var e = {}; try { for (var r in We(e, "x", { enumerable: !1, value: e }), e) return !1; return e.x === e } catch (e) { return !1 } }(); Ve.supportsDescriptors = !!Xe; function $e() { return "function" == typeof or && ("function" == typeof Symbol && ("symbol" == typeof or("foo") && ("symbol" == typeof Symbol("bar") && function () { if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return !1; if ("symbol" == typeof Symbol.iterator) return !0; var e = {}, r = Symbol("test"), t = Object(r); if ("string" == typeof r) return !1; if ("[object Symbol]" !== Object.prototype.toString.call(r)) return !1; if ("[object Symbol]" !== Object.prototype.toString.call(t)) return !1; for (r in e[r] = 42, e) return !1; if ("function" == typeof Object.keys && 0 !== Object.keys(e).length) return !1; if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e).length) return !1; var n = Object.getOwnPropertySymbols(e); if (1 !== n.length || n[0] !== r) return !1; if (!Object.prototype.propertyIsEnumerable.call(e, r)) return !1; if ("function" == typeof Object.getOwnPropertyDescriptor) { var o = Object.getOwnPropertyDescriptor(e, r); if (42 !== o.value || !0 !== o.enumerable) return !1 } return !0 }()))) } function Ze(e) { try { return Function('"use strict"; return (' + e + ").constructor;")() } catch (e) { } } var Qe, er = Ve, rr = Array.prototype.slice, tr = Object.prototype.toString, nr = Function.prototype.bind || function (r) { var t = this; if ("function" != typeof t || "[object Function]" !== tr.call(t)) throw new TypeError("Function.prototype.bind called on incompatible " + t); for (var n, o = rr.call(arguments, 1), e = Math.max(0, t.length - o.length), i = [], a = 0; a < e; a++)i.push("$" + a); if (n = Function("binder", "return function (" + i.join(",") + "){ return binder.apply(this,arguments); }")(function () { if (this instanceof n) { var e = t.apply(this, o.concat(rr.call(arguments))); return Object(e) === e ? e : this } return t.apply(r, o.concat(rr.call(arguments))) }), t.prototype) { var s = function () { }; s.prototype = t.prototype, n.prototype = new s, s.prototype = null } return n }, or = b.Symbol, ir = nr.call(Function.call, Object.prototype.hasOwnProperty), ar = SyntaxError, sr = Function, ur = TypeError, lr = Object.getOwnPropertyDescriptor; if (lr) try { lr({}, "") } catch (e) { lr = null } function cr() { throw new ur } function dr(e, r) { if ("string" != typeof e || 0 === e.length) throw new ur("intrinsic name must be a non-empty string"); if (1 < arguments.length && "boolean" != typeof r) throw new ur('"allowMissing" argument must be a boolean'); var o, t = (o = [], Mr(e, Ar, function (e, r, t, n) { o[o.length] = t ? Mr(n, Rr, "$1") : r || e }), o), n = 0 < t.length ? t[0] : "", i = function (e, r) { var t, n = e; if (ir(Er, n) && (n = "%" + (t = Er[n])[0] + "%"), ir(Pr, n)) { var o = Pr[n]; if (void 0 === o && !r) throw new ur("intrinsic " + e + " exists, but is not available. Please file an issue!"); return { alias: t, name: n, value: o } } throw new ar("intrinsic " + e + " does not exist!") }("%" + n + "%", r), a = i.name, s = i.value, u = !1, l = i.alias; l && (n = l[0], Tr(t, Sr([0, 1], l))); for (var c = 1, d = !0; c < t.length; c += 1) { var g = t[c]; if ("constructor" !== g && d || (u = !0), ir(Pr, a = "%" + (n += "." + g) + "%")) s = Pr[a]; else if (null != s) { if (lr && c + 1 >= t.length) { var f = lr(s, g); if (d = !!f, !(r || g in s)) throw new ur("base intrinsic for " + e + " exists, but the property is not available."); s = d && "get" in f && !("originalValue" in f.get) ? f.get : s[g] } else d = ir(s, g), s = s[g]; d && !u && (Pr[a] = s) } } return s } function gr(e) { return e != e } function fr(e, r) { return 0 === e && 0 === r ? 1 / e == 1 / r : e === r || !(!gr(e) || !gr(r)) } function mr() { return "function" == typeof Object.is ? Object.is : fr } var hr = lr ? function () { try { return cr } catch (e) { try { return lr(arguments, "callee").get } catch (e) { return cr } } }() : cr, pr = $e(), yr = Object.getPrototypeOf || function (e) { return e.__proto__ }, vr = Ze("async function* () {}"), br = vr ? vr.prototype : Qe, wr = br ? br.prototype : Qe, kr = "undefined" == typeof Uint8Array ? Qe : yr(Uint8Array), Pr = { "%AggregateError%": "undefined" == typeof AggregateError ? Qe : AggregateError, "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? Qe : ArrayBuffer, "%ArrayIteratorPrototype%": pr ? yr([][Symbol.iterator]()) : Qe, "%AsyncFromSyncIteratorPrototype%": Qe, "%AsyncFunction%": Ze("async function () {}"), "%AsyncGenerator%": br, "%AsyncGeneratorFunction%": vr, "%AsyncIteratorPrototype%": wr ? yr(wr) : Qe, "%Atomics%": "undefined" == typeof Atomics ? Qe : Atomics, "%BigInt%": "undefined" == typeof BigInt ? Qe : BigInt, "%Boolean%": Boolean, "%DataView%": "undefined" == typeof DataView ? Qe : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": "undefined" == typeof Float32Array ? Qe : Float32Array, "%Float64Array%": "undefined" == typeof Float64Array ? Qe : Float64Array, "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? Qe : FinalizationRegistry, "%Function%": sr, "%GeneratorFunction%": Ze("function* () {}"), "%Int8Array%": "undefined" == typeof Int8Array ? Qe : Int8Array, "%Int16Array%": "undefined" == typeof Int16Array ? Qe : Int16Array, "%Int32Array%": "undefined" == typeof Int32Array ? Qe : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": pr ? yr(yr([][Symbol.iterator]())) : Qe, "%JSON%": "object" == typeof JSON ? JSON : Qe, "%Map%": "undefined" == typeof Map ? Qe : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && pr ? yr((new Map)[Symbol.iterator]()) : Qe, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? Qe : Promise, "%Proxy%": "undefined" == typeof Proxy ? Qe : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": "undefined" == typeof Reflect ? Qe : Reflect, "%RegExp%": RegExp, "%Set%": "undefined" == typeof Set ? Qe : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && pr ? yr((new Set)[Symbol.iterator]()) : Qe, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? Qe : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": pr ? yr(""[Symbol.iterator]()) : Qe, "%Symbol%": pr ? Symbol : Qe, "%SyntaxError%": ar, "%ThrowTypeError%": hr, "%TypedArray%": kr, "%TypeError%": ur, "%Uint8Array%": "undefined" == typeof Uint8Array ? Qe : Uint8Array, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? Qe : Uint8ClampedArray, "%Uint16Array%": "undefined" == typeof Uint16Array ? Qe : Uint16Array, "%Uint32Array%": "undefined" == typeof Uint32Array ? Qe : Uint32Array, "%URIError%": URIError, "%WeakMap%": "undefined" == typeof WeakMap ? Qe : WeakMap, "%WeakRef%": "undefined" == typeof WeakRef ? Qe : WeakRef, "%WeakSet%": "undefined" == typeof WeakSet ? Qe : WeakSet }, Er = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, Sr = nr.call(Function.call, Array.prototype.concat), Tr = nr.call(Function.apply, Array.prototype.splice), Mr = nr.call(Function.call, String.prototype.replace), Ar = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Rr = /\\(\\)?/g, Cr = g(function (e) { var r = dr("%Function.prototype.apply%"), t = dr("%Function.prototype.call%"), n = dr("%Reflect.apply%", !0) || nr.call(t, r), o = dr("%Object.defineProperty%", !0); if (o) try { o({}, "a", { value: 1 }) } catch (e) { o = null } e.exports = function () { return n(nr, t, arguments) }; function i() { return n(nr, r, arguments) } o ? o(e.exports, "apply", { value: i }) : e.exports.apply = i }), xr = (Cr.apply, Cr(mr(), Object)); er(xr, { getPolyfill: mr, implementation: fr, shim: function () { var e = mr(); return er(Object, { is: e }, { is: function () { return Object.is !== e } }), e } }); var Fr, Or = xr, Lr = RegExp.prototype.exec, _r = Object.getOwnPropertyDescriptor, jr = Object.prototype.toString, Ir = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, zr = function (e) { if (!e || "object" != typeof e) return !1; if (!Ir) return "[object RegExp]" === jr.call(e); var r = _r(e, "lastIndex"); return !(!r || !ir(r, "value")) && function (e) { try { var r = e.lastIndex; return e.lastIndex = 0, Lr.call(e), !0 } catch (e) { return !1 } finally { e.lastIndex = r } }(e) }, Dr = TypeError, Nr = Object.getOwnPropertyDescriptor; if (Nr) try { Nr({}, "") } catch (e) { Nr = null } function Br() { throw new Dr } function Gr() { return nr.apply(Zr, arguments) } var Ur = Nr ? function () { try { return Br } catch (e) { try { return Nr(arguments, "callee").get } catch (e) { return Br } } }() : Br, qr = $e(), Vr = Object.getPrototypeOf || function (e) { return e.__proto__ }, Kr = "undefined" == typeof Uint8Array ? Fr : Vr(Uint8Array), Hr = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? Fr : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? Fr : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": qr ? Vr([][Symbol.iterator]()) : Fr, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": Fr, "%AsyncFunction%": void 0, "%AsyncFunctionPrototype%": Fr, "%AsyncGenerator%": Fr, "%AsyncGeneratorFunction%": void 0, "%AsyncGeneratorPrototype%": Fr, "%AsyncIteratorPrototype%": Fr, "%Atomics%": "undefined" == typeof Atomics ? Fr : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? Fr : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? Fr : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? Fr : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? Fr : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? Fr : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? Fr : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": Fr, "%GeneratorFunction%": void 0, "%GeneratorPrototype%": Fr, "%Int8Array%": "undefined" == typeof Int8Array ? Fr : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? Fr : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? Fr : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? Fr : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? Fr : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? Fr : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": qr ? Vr(Vr([][Symbol.iterator]())) : Fr, "%JSON%": "object" == typeof JSON ? JSON : Fr, "%JSONParse%": "object" == typeof JSON ? JSON.parse : Fr, "%Map%": "undefined" == typeof Map ? Fr : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && qr ? Vr((new Map)[Symbol.iterator]()) : Fr, "%MapPrototype%": "undefined" == typeof Map ? Fr : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? Fr : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? Fr : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? Fr : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? Fr : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? Fr : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? Fr : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? Fr : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? Fr : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? Fr : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && qr ? Vr((new Set)[Symbol.iterator]()) : Fr, "%SetPrototype%": "undefined" == typeof Set ? Fr : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? Fr : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? Fr : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": qr ? Vr(""[Symbol.iterator]()) : Fr, "%StringPrototype%": String.prototype, "%Symbol%": qr ? Symbol : Fr, "%SymbolPrototype%": qr ? Symbol.prototype : Fr, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": Ur, "%TypedArray%": Kr, "%TypedArrayPrototype%": Kr ? Kr.prototype : Fr, "%TypeError%": Dr, "%TypeErrorPrototype%": Dr.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? Fr : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? Fr : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? Fr : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? Fr : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? Fr : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? Fr : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? Fr : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? Fr : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? Fr : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? Fr : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? Fr : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? Fr : WeakSet.prototype }, Jr = nr.call(Function.call, String.prototype.replace), Yr = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Wr = /\\(\\)?/g, Xr = function (e, r) { if ("string" != typeof e || 0 === e.length) throw new TypeError("intrinsic name must be a non-empty string"); if (1 < arguments.length && "boolean" != typeof r) throw new TypeError('"allowMissing" argument must be a boolean'); for (var o, t = (o = [], Jr(e, Yr, function (e, r, t, n) { o[o.length] = t ? Jr(n, Wr, "$1") : r || e }), o), n = function (e, r) { if (!(e in Hr)) throw new SyntaxError("intrinsic " + e + " does not exist!"); if (void 0 === Hr[e] && !r) throw new Dr("intrinsic " + e + " exists, but is not available. Please file an issue!"); return Hr[e] }("%" + (0 < t.length ? t[0] : "") + "%", r), i = 1; i < t.length; i += 1)if (null != n) if (Nr && i + 1 >= t.length) { var a = Nr(n, t[i]); if (!(r || t[i] in n)) throw new Dr("base intrinsic for " + e + " exists, but the property is not available."); n = a ? a.get || a.value : n[t[i]] } else n = n[t[i]]; return n }("%Function%"), $r = Xr.apply, Zr = Xr.call; Gr.apply = function () { return nr.apply($r, arguments) }; function Qr() { if (null != this && this !== rt(this)) throw new tt("RegExp.prototype.flags getter called on non-object"); var e = ""; return this.global && (e += "g"), this.ignoreCase && (e += "i"), this.multiline && (e += "m"), this.dotAll && (e += "s"), this.unicode && (e += "u"), this.sticky && (e += "y"), e } function et() { if (!nt) throw new it("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors"); if ("gim" === /a/gim.flags) { var e = ot(RegExp.prototype, "flags"); if (e && "function" == typeof e.get && "boolean" == typeof /a/.dotAll) return e.get } return Qr } var rt = Object, tt = TypeError, nt = er.supportsDescriptors, ot = Object.getOwnPropertyDescriptor, it = TypeError, at = er.supportsDescriptors, st = Object.getOwnPropertyDescriptor, ut = Object.defineProperty, lt = TypeError, ct = Object.getPrototypeOf, dt = /a/, gt = Gr(Qr); er(gt, { getPolyfill: et, implementation: Qr, shim: function () { if (!at || !ct) throw new lt("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors"); var e = et(), r = ct(dt), t = st(r, "flags"); return t && t.get === e || ut(r, "flags", { configurable: !0, enumerable: !1, get: e }), e } }); var ft = gt, mt = Date.prototype.getDay, ht = Object.prototype.toString, pt = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, yt = function (e) { return "object" == typeof e && null !== e && (pt ? function (e) { try { return mt.call(e), !0 } catch (e) { return !1 } }(e) : "[object Date]" === ht.call(e)) }, vt = Date.prototype.getTime; function bt(e, r, t) { var n = t || {}; return !(n.strict ? !Or(e, r) : e !== r) || (!e || !r || "object" != typeof e && "object" != typeof r ? n.strict ? Or(e, r) : e == r : function (e, r, t) { var n, o; if (typeof e != typeof r) return !1; if (wt(e) || wt(r)) return !1; if (e.prototype !== r.prototype) return !1; if (Ke(e) !== Ke(r)) return !1; var i = zr(e), a = zr(r); if (i !== a) return !1; if (i || a) return e.source === r.source && ft(e) === ft(r); if (yt(e) && yt(r)) return vt.call(e) === vt.call(r); var s = kt(e), u = kt(r); if (s !== u) return !1; if (s || u) { if (e.length !== r.length) return !1; for (n = 0; n < e.length; n++)if (e[n] !== r[n]) return !1; return !0 } if (typeof e != typeof r) return !1; try { var l = Ne(e), c = Ne(r) } catch (e) { return !1 } if (l.length !== c.length) return !1; for (l.sort(), c.sort(), n = l.length - 1; 0 <= n; n--)if (l[n] != c[n]) return !1; for (n = l.length - 1; 0 <= n; n--)if (o = l[n], !bt(e[o], r[o], t)) return !1; return !0 }(e, r, n)) } function wt(e) { return null == e } function kt(e) { return !(!e || "object" != typeof e || "number" != typeof e.length) && ("function" == typeof e.copy && "function" == typeof e.slice && !(0 < e.length && "number" != typeof e[0])) } var Pt = bt, Et = g(function (e, r) { function l(e, r) { var t = ye.getCoords(r), n = ye.getCoords(e), o = n[0], i = n[n.length - 1], a = e.geometry.coordinates; return Pt(t[0], o) ? a.unshift(t[1]) : Pt(t[0], i) ? a.push(t[1]) : Pt(t[1], o) ? a.unshift(t[0]) : Pt(t[1], i) && a.push(t[0]), e } Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function (e, r, t) { if (void 0 === t && (t = {}), t = t || {}, !pe.isObject(t)) throw new Error("options is invalid"); var i, a = t.tolerance || 0, s = [], u = V.default(), n = W.default(e); return u.load(n), ve.segmentEach(r, function (n) { var o = !1; ve.featureEach(u.search(n), function (e) { if (!1 === o) { var r = ye.getCoords(n).sort(), t = ye.getCoords(e).sort(); Pt(r, t) || (0 === a ? he.default(r[0], e) && he.default(r[1], e) : ge.default(e, r[0]).properties.dist <= a && ge.default(e, r[1]).properties.dist <= a) ? (o = !0, i = i ? l(i, n) : n) : (0 === a ? he.default(t[0], n) && he.default(t[1], n) : ge.default(n, t[0]).properties.dist <= a && ge.default(n, t[1]).properties.dist <= a) && (i = i ? l(i, e) : e) } }), !1 === o && i && (s.push(i), i = void 0) }), i && s.push(i), pe.featureCollection(s) } }); c(Et); function St(e) { this.precision = e && e.precision ? e.precision : 17, this.direction = !(!e || !e.direction) && e.direction, this.pseudoNode = !(!e || !e.pseudoNode) && e.pseudoNode, this.objectComparator = e && e.objectComparator ? e.objectComparator : At } function Tt(r) { return r.coordinates.map(function (e) { return { type: r.type.replace("Multi", ""), coordinates: e } }) } function Mt(e, r) { return e.hasOwnProperty("coordinates") ? e.coordinates.length === r.coordinates.length : e.length === r.length } function At(e, r) { return Pt(e, r, { strict: !0 }) } St.prototype.compare = function (e, r) { if (e.type !== r.type || !Mt(e, r)) return !1; switch (e.type) { case "Point": return this.compareCoord(e.coordinates, r.coordinates); case "LineString": return this.compareLine(e.coordinates, r.coordinates, 0, !1); case "Polygon": return this.comparePolygon(e, r); case "Feature": return this.compareFeature(e, r); default: if (0 === e.type.indexOf("Multi")) { var t = this, n = Tt(e), o = Tt(r); return n.every(function (r) { return this.some(function (e) { return t.compare(r, e) }) }, o) } }return !1 }, St.prototype.compareCoord = function (e, r) { if (e.length !== r.length) return !1; for (var t = 0; t < e.length; t++)if (e[t].toFixed(this.precision) !== r[t].toFixed(this.precision)) return !1; return !0 }, St.prototype.compareLine = function (e, r, t, n) { if (!Mt(e, r)) return !1; var o = this.pseudoNode ? e : this.removePseudo(e), i = this.pseudoNode ? r : this.removePseudo(r); if (!n || this.compareCoord(o[0], i[0]) || (i = this.fixStartIndex(i, o))) { var a = this.compareCoord(o[t], i[t]); return this.direction || a ? this.comparePath(o, i) : !!this.compareCoord(o[t], i[i.length - (1 + t)]) && this.comparePath(o.slice().reverse(), i) } }, St.prototype.fixStartIndex = function (e, r) { for (var t, n = -1, o = 0; o < e.length; o++)if (this.compareCoord(e[o], r[0])) { n = o; break } return 0 <= n && (t = [].concat(e.slice(n, e.length), e.slice(1, n + 1))), t }, St.prototype.comparePath = function (e, r) { var t = this; return e.every(function (e, r) { return t.compareCoord(e, this[r]) }, r) }, St.prototype.comparePolygon = function (e, r) { if (this.compareLine(e.coordinates[0], r.coordinates[0], 1, !0)) { var t = e.coordinates.slice(1, e.coordinates.length), n = r.coordinates.slice(1, r.coordinates.length), o = this; return t.every(function (r) { return this.some(function (e) { return o.compareLine(r, e, 1, !0) }) }, n) } return !1 }, St.prototype.compareFeature = function (e, r) { return !(e.id !== r.id || !this.objectComparator(e.properties, r.properties) || !this.compareBBox(e, r)) && this.compare(e.geometry, r.geometry) }, St.prototype.compareBBox = function (e, r) { return !!(!e.bbox && !r.bbox || e.bbox && r.bbox && this.compareCoord(e.bbox, r.bbox)) }, St.prototype.removePseudo = function (e) { return e }; var Rt = St, Ct = c(g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function (e, t) { if (!e) throw new Error("feature1 is required"); if (!t) throw new Error("feature2 is required"); var r = y.getType(e); if (r !== y.getType(t)) throw new Error("features must be of the same type"); if ("Point" === r) throw new Error("Point geometry not supported"); if (new Rt({ precision: 6 }).compare(e, t)) return !1; var n = 0; switch (r) { case "MultiPoint": var o = f.coordAll(e), i = f.coordAll(t); o.forEach(function (r) { i.forEach(function (e) { r[0] === e[0] && r[1] === e[1] && n++ }) }); break; case "LineString": case "MultiLineString": f.segmentEach(e, function (r) { f.segmentEach(t, function (e) { Et.default(r, e).features.length && n++ }) }); break; case "Polygon": case "MultiPolygon": f.segmentEach(e, function (r) { f.segmentEach(t, function (e) { ue.default(r, e).features.length && n++ }) }) }return 0 < n } })), xt = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(xt); xt.earthRadius, xt.factors, xt.unitsFactors, xt.areaFactors, xt.feature, xt.geometry, xt.point, xt.points, xt.polygon, xt.polygons, xt.lineString, xt.lineStrings, xt.featureCollection, xt.multiLineString, xt.multiPoint, xt.multiPolygon, xt.geometryCollection, xt.round, xt.radiansToLength, xt.lengthToRadians, xt.lengthToDegrees, xt.bearingToAzimuth, xt.radiansToDegrees, xt.degreesToRadians, xt.convertLength, xt.convertArea, xt.isNumber, xt.isObject, xt.validateBBox, xt.validateId, xt.radians2degrees, xt.degrees2radians, xt.distanceToDegrees, xt.distanceToRadians, xt.radiansToDistance, xt.bearingToAngle, xt.convertDistance; var Ft = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.getCoord = function (e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && 2 <= e.length && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") }, r.getCoords = function (e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }, r.containsNumber = function e(r) { if (1 < r.length && xt.isNumber(r[0]) && xt.isNumber(r[1])) return !0; if (Array.isArray(r[0]) && r[0].length) return e(r[0]); throw new Error("coordinates must only contain numbers") }, r.geojsonType = function (e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) }, r.featureOf = function (e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) }, r.collectionOf = function (e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var n = 0, o = e.features; n < o.length; n++) { var i = o[n]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } }, r.getGeom = function (e) { return "Feature" === e.type ? e.geometry : e }, r.getType = function (e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } }); c(Ft); Ft.getCoord, Ft.getCoords, Ft.containsNumber, Ft.geojsonType, Ft.featureOf, Ft.collectionOf, Ft.getGeom, Ft.getType; var Ot = g(function (e, r) { function n(e, r) { void 0 === r && (r = {}); var t = Ft.getGeom(e); t.type; return a(t.coordinates, r.properties ? r.properties : "Feature" === e.type ? e.properties : {}) } function o(e, r) { void 0 === r && (r = {}); var t = Ft.getGeom(e), n = (t.type, t.coordinates), o = r.properties ? r.properties : "Feature" === e.type ? e.properties : {}, i = []; return n.forEach(function (e) { i.push(a(e, o)) }), xt.featureCollection(i) } function a(e, r) { return 1 < e.length ? xt.multiLineString(e, r) : xt.lineString(e[0], r) } Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function (e, r) { void 0 === r && (r = {}); var t = Ft.getGeom(e); switch (r.properties || "Feature" !== e.type || (r.properties = e.properties), t.type) { case "Polygon": return n(t, r); case "MultiPolygon": return o(t, r); default: throw new Error("invalid poly") } }, r.polygonToLine = n, r.multiPolygonToLine = o, r.coordsToLine = a }); c(Ot); Ot.polygonToLine, Ot.multiPolygonToLine, Ot.coordsToLine; var Lt = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(Lt); Lt.earthRadius, Lt.factors, Lt.unitsFactors, Lt.areaFactors, Lt.feature, Lt.geometry, Lt.point, Lt.points, Lt.polygon, Lt.polygons, Lt.lineString, Lt.lineStrings, Lt.featureCollection, Lt.multiLineString, Lt.multiPoint, Lt.multiPolygon, Lt.geometryCollection, Lt.round, Lt.radiansToLength, Lt.lengthToRadians, Lt.lengthToDegrees, Lt.bearingToAzimuth, Lt.radiansToDegrees, Lt.degreesToRadians, Lt.convertLength, Lt.convertArea, Lt.isNumber, Lt.isObject, Lt.validateBBox, Lt.validateId, Lt.radians2degrees, Lt.degrees2radians, Lt.distanceToDegrees, Lt.distanceToRadians, Lt.radiansToDistance, Lt.bearingToAngle, Lt.convertDistance; var _t = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.getCoord = function (e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && 2 <= e.length && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") }, r.getCoords = function (e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }, r.containsNumber = function e(r) { if (1 < r.length && Lt.isNumber(r[0]) && Lt.isNumber(r[1])) return !0; if (Array.isArray(r[0]) && r[0].length) return e(r[0]); throw new Error("coordinates must only contain numbers") }, r.geojsonType = function (e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) }, r.featureOf = function (e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) }, r.collectionOf = function (e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var n = 0, o = e.features; n < o.length; n++) { var i = o[n]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } }, r.getGeom = function (e) { return "Feature" === e.type ? e.geometry : e }, r.getType = function (e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } }); c(_t); _t.getCoord, _t.getCoords, _t.containsNumber, _t.geojsonType, _t.featureOf, _t.collectionOf, _t.getGeom, _t.getType; var jt = g(function (e, r) { function m(e, r, t) { var n = !1; r[0][0] === r[r.length - 1][0] && r[0][1] === r[r.length - 1][1] && (r = r.slice(0, r.length - 1)); for (var o = 0, i = r.length - 1; o < r.length; i = o++) { var a = r[o][0], s = r[o][1], u = r[i][0], l = r[i][1]; if (e[1] * (a - u) + s * (u - e[0]) + l * (e[0] - a) == 0 && (a - e[0]) * (u - e[0]) <= 0 && (s - e[1]) * (l - e[1]) <= 0) return !t; s > e[1] != l > e[1] && e[0] < (u - a) * (e[1] - s) / (l - s) + a && (n = !n) } return n } Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function (e, r, t) { if (void 0 === t && (t = {}), !e) throw new Error("point is required"); if (!r) throw new Error("polygon is required"); var n, o, i = _t.getCoord(e), a = _t.getGeom(r), s = a.type, u = r.bbox, l = a.coordinates; if (u && !1 == (n = i, (o = u)[0] <= n[0] && o[1] <= n[1] && o[2] >= n[0] && o[3] >= n[1])) return !1; "Polygon" === s && (l = [l]); for (var c = !1, d = 0; d < l.length && !c; d++)if (m(i, l[d][0], t.ignoreBoundary)) { for (var g = !1, f = 1; f < l[d].length && !g;)m(i, l[d][f], !t.ignoreBoundary) && (g = !0), f++; g || (c = !0) } return c } }); c(jt); var It = c(g(function (e, r) { function a(e, r) { for (var t = !1, n = !1, o = e.coordinates.length, i = 0; i < o && !t && !n;) { for (var a = 0; a < r.coordinates.length - 1; a++) { var s = !0; 0 !== a && a !== r.coordinates.length - 2 || (s = !1), l(r.coordinates[a], r.coordinates[a + 1], e.coordinates[i], s) ? t = !0 : n = !0 } i++ } return t && n } function s(e, r) { var t = Ot.polygonToLine(r); return 0 < ue.default(e, t).features.length } function u(e, r) { for (var t = !1, n = !1, o = e.coordinates[0].length, i = 0; i < o && t && n;)jt.default(Lt.point(e.coordinates[0][i]), r) ? t = !0 : n = !0, i++; return n && n } function l(e, r, t, n) { var o = t[0] - e[0], i = t[1] - e[1], a = r[0] - e[0], s = r[1] - e[1]; return 0 == o * s - i * a && (n ? Math.abs(a) >= Math.abs(s) ? 0 < a ? e[0] <= t[0] && t[0] <= r[0] : r[0] <= t[0] && t[0] <= e[0] : 0 < s ? e[1] <= t[1] && t[1] <= r[1] : r[1] <= t[1] && t[1] <= e[1] : Math.abs(a) >= Math.abs(s) ? 0 < a ? e[0] < t[0] && t[0] < r[0] : r[0] < t[0] && t[0] < e[0] : 0 < s ? e[1] < t[1] && t[1] < r[1] : r[1] < t[1] && t[1] < e[1]) } Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function (e, r) { var t = _t.getType(e), n = _t.getType(r), o = _t.getGeom(e), i = _t.getGeom(r); switch (t) { case "MultiPoint": switch (n) { case "LineString": return a(o, i); case "Polygon": return u(o, i); default: throw new Error("feature2 " + n + " geometry not supported") }case "LineString": switch (n) { case "MultiPoint": return a(i, o); case "LineString": return function (e, r) { if (0 < ue.default(e, r).features.length) for (var t = 0; t < e.coordinates.length - 1; t++)for (var n = 0; n < r.coordinates.length - 1; n++) { var o = !0; if (0 !== n && n !== r.coordinates.length - 2 || (o = !1), l(e.coordinates[t], e.coordinates[t + 1], r.coordinates[n], o)) return !0 } return !1 }(o, i); case "Polygon": return s(o, i); default: throw new Error("feature2 " + n + " geometry not supported") }case "Polygon": switch (n) { case "MultiPoint": return u(i, o); case "LineString": return s(i, o); default: throw new Error("feature2 " + n + " geometry not supported") }default: throw new Error("feature1 " + t + " geometry not supported") } } })), zt = g(function (e, i) { function s(e, r, t) { void 0 === t && (t = {}); var n = { type: "Feature" }; return 0 !== t.id && !t.id || (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = r || {}, n.geometry = e, n } function n(e, r, t) { return void 0 === t && (t = {}), s({ type: "Point", coordinates: e }, r, t) } function o(e, r, t) { void 0 === t && (t = {}); for (var n = 0, o = e; n < o.length; n++) { var i = o[n]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var a = 0; a < i[i.length - 1].length; a++)if (i[i.length - 1][a] !== i[0][a]) throw new Error("First and last Position are not equivalent.") } return s({ type: "Polygon", coordinates: e }, r, t) } function a(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return s({ type: "LineString", coordinates: e }, r, t) } function u(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function l(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiLineString", coordinates: e }, r, t) } function c(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPoint", coordinates: e }, r, t) } function d(e, r, t) { return void 0 === t && (t = {}), s({ type: "MultiPolygon", coordinates: e }, r, t) } function g(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function f(e, r) { void 0 === r && (r = "kilometers"); var t = i.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function t(e) { return 180 * (e % (2 * Math.PI)) / Math.PI } function r(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } Object.defineProperty(i, "__esModule", { value: !0 }), i.earthRadius = 6371008.8, i.factors = { centimeters: 100 * i.earthRadius, centimetres: 100 * i.earthRadius, degrees: i.earthRadius / 111325, feet: 3.28084 * i.earthRadius, inches: 39.37 * i.earthRadius, kilometers: i.earthRadius / 1e3, kilometres: i.earthRadius / 1e3, meters: i.earthRadius, metres: i.earthRadius, miles: i.earthRadius / 1609.344, millimeters: 1e3 * i.earthRadius, millimetres: 1e3 * i.earthRadius, nauticalmiles: i.earthRadius / 1852, radians: 1, yards: i.earthRadius / 1.0936 }, i.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / i.earthRadius, yards: 1 / 1.0936 }, i.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, i.feature = s, i.geometry = function (e, r, t) { switch (e) { case "Point": return n(r).geometry; case "LineString": return a(r).geometry; case "Polygon": return o(r).geometry; case "MultiPoint": return c(r).geometry; case "MultiLineString": return l(r).geometry; case "MultiPolygon": return d(r).geometry; default: throw new Error(e + " is invalid") } }, i.point = n, i.points = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return n(e, r) }), t) }, i.polygon = o, i.polygons = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return o(e, r) }), t) }, i.lineString = a, i.lineStrings = function (e, r, t) { return void 0 === t && (t = {}), u(e.map(function (e) { return a(e, r) }), t) }, i.featureCollection = u, i.multiLineString = l, i.multiPoint = c, i.multiPolygon = d, i.geometryCollection = function (e, r, t) { return void 0 === t && (t = {}), s({ type: "GeometryCollection", geometries: e }, r, t) }, i.round = function (e, r) { if (void 0 === r && (r = 0), r && !(0 <= r)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t }, i.radiansToLength = g, i.lengthToRadians = f, i.lengthToDegrees = function (e, r) { return t(f(e, r)) }, i.bearingToAzimuth = function (e) { var r = e % 360; return r < 0 && (r += 360), r }, i.radiansToDegrees = t, i.degreesToRadians = function (e) { return e % 360 * Math.PI / 180 }, i.convertLength = function (e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("length must be a positive number"); return g(f(e, r), t) }, i.convertArea = function (e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(0 <= e)) throw new Error("area must be a positive number"); var n = i.areaFactors[r]; if (!n) throw new Error("invalid original units"); var o = i.areaFactors[t]; if (!o) throw new Error("invalid final units"); return e / n * o }, i.isNumber = r, i.isObject = function (e) { return !!e && e.constructor === Object }, i.validateBBox = function (e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!r(e)) throw new Error("bbox must only contain numbers") }) }, i.validateId = function (e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") }, i.radians2degrees = function () { throw new Error("method has been renamed to `radiansToDegrees`") }, i.degrees2radians = function () { throw new Error("method has been renamed to `degreesToRadians`") }, i.distanceToDegrees = function () { throw new Error("method has been renamed to `lengthToDegrees`") }, i.distanceToRadians = function () { throw new Error("method has been renamed to `lengthToRadians`") }, i.radiansToDistance = function () { throw new Error("method has been renamed to `radiansToLength`") }, i.bearingToAngle = function () { throw new Error("method has been renamed to `bearingToAzimuth`") }, i.convertDistance = function () { throw new Error("method has been renamed to `convertLength`") } }); c(zt); zt.earthRadius, zt.factors, zt.unitsFactors, zt.areaFactors, zt.feature, zt.geometry, zt.point, zt.points, zt.polygon, zt.polygons, zt.lineString, zt.lineStrings, zt.featureCollection, zt.multiLineString, zt.multiPoint, zt.multiPolygon, zt.geometryCollection, zt.round, zt.radiansToLength, zt.lengthToRadians, zt.lengthToDegrees, zt.bearingToAzimuth, zt.radiansToDegrees, zt.degreesToRadians, zt.convertLength, zt.convertArea, zt.isNumber, zt.isObject, zt.validateBBox, zt.validateId, zt.radians2degrees, zt.degrees2radians, zt.distanceToDegrees, zt.distanceToRadians, zt.radiansToDistance, zt.bearingToAngle, zt.convertDistance; var Dt = g(function (e, r) { Object.defineProperty(r, "__esModule", { value: !0 }), r.getCoord = function (e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && 2 <= e.length && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") }, r.getCoords = function (e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") }, r.containsNumber = function e(r) { if (1 < r.length && zt.isNumber(r[0]) && zt.isNumber(r[1])) return !0; if (Array.isArray(r[0]) && r[0].length) return e(r[0]); throw new Error("coordinates must only contain numbers") }, r.geojsonType = function (e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) }, r.featureOf = function (e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) }, r.collectionOf = function (e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var n = 0, o = e.features; n < o.length; n++) { var i = o[n]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } }, r.getGeom = function (e) { return "Feature" === e.type ? e.geometry : e }, r.getType = function (e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } }); c(Dt); Dt.getCoord, Dt.getCoords, Dt.containsNumber, Dt.geojsonType, Dt.featureOf, Dt.collectionOf, Dt.getGeom, Dt.getType; var Nt = g(function (e, r) { function m(e, r, t) { var n = !1; r[0][0] === r[r.length - 1][0] && r[0][1] === r[r.length - 1][1] && (r = r.slice(0, r.length - 1)); for (var o = 0, i = r.length - 1; o < r.length; i = o++) { var a = r[o][0], s = r[o][1], u = r[i][0], l = r[i][1]; if (e[1] * (a - u) + s * (u - e[0]) + l * (e[0] - a) == 0 && (a - e[0]) * (u - e[0]) <= 0 && (s - e[1]) * (l - e[1]) <= 0) return !t; s > e[1] != l > e[1] && e[0] < (u - a) * (e[1] - s) / (l - s) + a && (n = !n) } return n } Object.defineProperty(r, "__esModule", { value: !0 }), r.default = function (e, r, t) { if (void 0 === t && (t = {}), !e) throw new Error("point is required"); if (!r) throw new Error("polygon is required"); var n, o, i = Dt.getCoord(e), a = Dt.getGeom(r), s = a.type, u = r.bbox, l = a.coordinates; if (u && !1 == (n = i, (o = u)[0] <= n[0] && o[1] <= n[1] && o[2] >= n[0] && o[3] >= n[1])) return !1; "Polygon" === s && (l = [l]); for (var c = !1, d = 0; d < l.length && !c; d++)if (m(i, l[d][0], t.ignoreBoundary)) { for (var g = !1, f = 1; f < l[d].length && !g;)m(i, l[d][f], !t.ignoreBoundary) && (g = !0), f++; g || (c = !0) } return c } }); c(Nt); var Bt, Gt = g(function (e, r) { var t = b && b.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(r, "__esModule", { value: !0 }); var s = t(N), u = t(Nt), l = t(he); function c(e, r) { var t, n = !1; for (t = 0; t < e.coordinates.length; t++)if (v(e.coordinates[t], r.coordinates)) { n = !0; break } return n } function d(e, r) { for (var t = 0, n = r.coordinates; t < n.length; t++) { for (var o = n[t], i = !1, a = 0, s = e.coordinates; a < s.length; a++) { if (v(o, s[a])) { i = !0; break } } if (!i) return !1 } return !0 } function g(e, r) { for (var t = !1, n = 0, o = r.coordinates; n < o.length; n++) { var i = o[n]; if (l.default(i, e, { ignoreEndVertices: !0 }) && (t = !0), !l.default(i, e)) return !1 } return !!t } function f(e, r) { for (var t = 0, n = r.coordinates; t < n.length; t++) { var o = n[t]; if (!u.default(o, e, { ignoreBoundary: !0 })) return !1 } return !0 } function m(e, r) { for (var t = !1, n = 0, o = r.coordinates; n < o.length; n++) { var i = o[n]; if (l.default({ type: "Point", coordinates: i }, e, { ignoreEndVertices: !0 }) && (t = !0), !l.default({ type: "Point", coordinates: i }, e, { ignoreEndVertices: !1 })) return !1 } return t } function h(e, r) { var t = !1, n = 0; if (!y(s.default(e), s.default(r))) return !1; for (; n < r.coordinates.length - 1; n++) { var o = i(r.coordinates[n], r.coordinates[n + 1]); if (u.default({ type: "Point", coordinates: o }, e, { ignoreBoundary: !0 })) { t = !0; break } } return t } function p(e, r) { if ("Feature" === e.type && null === e.geometry) return !1; if ("Feature" === r.type && null === r.geometry) return !1; if (!y(s.default(e), s.default(r))) return !1; for (var t = 0, n = Dt.getGeom(r).coordinates; t < n.length; t++)for (var o = 0, i = n[t]; o < i.length; o++) { var a = i[o]; if (!u.default(a, e)) return !1 } return !0 } function y(e, r) { return !(e[0] > r[0]) && (!(e[2] < r[2]) && (!(e[1] > r[1]) && !(e[3] < r[3]))) } function v(e, r) { return e[0] === r[0] && e[1] === r[1] } function i(e, r) { return [(e[0] + r[0]) / 2, (e[1] + r[1]) / 2] } r.default = function (e, r) { var t = Dt.getGeom(e), n = Dt.getGeom(r), o = Dt.getType(e), i = Dt.getType(r), a = Dt.getCoords(e), s = Dt.getCoords(r); switch (o) { case "Point": switch (i) { case "Point": return v(a, s); default: throw new Error("feature2 " + i + " geometry not supported") }case "MultiPoint": switch (i) { case "Point": return c(t, n); case "MultiPoint": return d(t, n); default: throw new Error("feature2 " + i + " geometry not supported") }case "LineString": switch (i) { case "Point": return l.default(n, t, { ignoreEndVertices: !0 }); case "LineString": return m(t, n); case "MultiPoint": return g(t, n); default: throw new Error("feature2 " + i + " geometry not supported") }case "Polygon": switch (i) { case "Point": return u.default(n, t, { ignoreBoundary: !0 }); case "LineString": return h(t, n); case "Polygon": return p(t, n); case "MultiPoint": return f(t, n); default: throw new Error("feature2 " + i + " geometry not supported") }default: throw new Error("feature1 " + o + " geometry not supported") } }, r.isPointInMultiPoint = c, r.isMultiPointInMultiPoint = d, r.isMultiPointOnLine = g, r.isMultiPointInPoly = f, r.isLineOnLine = m, r.isLineInPoly = h, r.isPolyInPoly = p, r.doBBoxOverlap = y, r.compareCoords = v, r.getMidpoint = i }), Ut = c(Gt); Gt.isPointInMultiPoint, Gt.isMultiPointInMultiPoint, Gt.isMultiPointOnLine, Gt.isMultiPointInPoly, Gt.isLineOnLine, Gt.isLineInPoly, Gt.isPolyInPoly, Gt.doBBoxOverlap, Gt.compareCoords, Gt.getMidpoint; (Bt = d.WeightUnits || (d.WeightUnits = {})).kilograms = "kilograms", Bt.pounds = "pounds", Bt.metricTon = "metricTon", Bt.longTon = "longTon", Bt.shortTon = "shortTon"; var qt = (Vt.createElm = function (e, t, n, r) { var o = document.createElement(e); if (t) { if (t.propName && n) { var i = n[t.propName]; i && (t.attr = Object.assign(t.attr || {}, { alt: i, title: i })) } "select" === e && t.selectVals && t.selectVals.forEach(function (e) { var r = document.createElement("option"); r.setAttribute("value", e), e === t.selected && r.setAttribute("selected", "true"), r.appendChild(document.createTextNode(n && n[e] ? n[e] : e)), o.appendChild(r) }), Vt.setAttributes(o, t.attr), t.class && t.class.forEach(function (e) { e && o.classList.add(e) }), t.style && Object.assign(o.style, t.style), Vt.appendChildren(o, t.children), t.innerHTML && (o.innerHTML += t.innerHTML), r && t.propName && r.bind(o, t.propName, null, t.bindingChanged) } return o }, Vt.appendChildren = function (r, e) { r && e && e.forEach(function (e) { r.appendChild(e) }) }, Vt.setAttributes = function (r, t) { r && t && Object.keys(t).forEach(function (e) { r.setAttribute(e, t[e]) }) }, Vt.isDateTimeInputSupported = function () { if ("boolean" != typeof this.isDateTimeSupported) { var e = "not-a-valid-value", r = this.createElm("input", { attr: { type: "date", value: e } }), t = r.value !== e, n = (r = this.createElm("input", { attr: { type: "time", value: e } })).value !== e; this.isDateTimeSupported = t && n } return this.isDateTimeSupported }, Vt.getPolygon = function (e) { var r; if (e instanceof p.Shape) e.isCircle() ? r = new p.data.Polygon([e.getCircleCoordinates()]) : -1 < e.getType().indexOf("Polygon") && (r = e.toJson().geometry); else { var t = e; "Feature" === t.type && ("Point" === t.geometry.type && "Circle" === t.properties.subType && "number" == typeof t.properties.radius ? r = new p.data.Polygon(p.math.getRegularPolygonPath(t.geometry.coordinates, t.properties.radius, 72, "meters")) : -1 < t.geometry.type.indexOf("Polygon") && (r = t.geometry)), -1 !== t.type.indexOf("Polygon") && (r = e) } return r }, Vt.getGeometry = function (e) { return e instanceof p.Shape ? e.isCircle() ? new p.data.Polygon([e.getCircleCoordinates()]) : e.toJson().geometry : null }, Vt.USNumberFormat = new Intl.NumberFormat("en-US", { useGrouping: !1 }).format, Vt); function Vt() { } var Kt = (Ht.pointsWithinPolygon = function (e, r) { if (e && 0 < e.length && r) { var t = qt.getPolygon(r); if (t) return l(new n.data.FeatureCollection(e), t).features } return [] }, Ht.shapePointsWithinPolygon = function (e, r) { return Ht.shapesIntersectPolygon(e, r, "point") }, Ht.shapesIntersectPolygon = function (e, r, t) { var n = []; if (e && r) { t = t || "any"; for (var o = e instanceof p.source.DataSource ? e.getShapes() : e, i = [], a = {}, s = void 0, u = void 0, l = void 0, c = qt.getPolygon(r), d = "point" === t || "any" === t, g = "line" === t || "any" === t, f = "polygon" === t || "any" === t, m = 0, h = o.length; m < h; m++)"Point" === (u = o[m]).getType() ? d && (s = u.getId(), a[s] = u, i.push(new p.data.Feature(new p.data.Point(u.getCoordinates()), null, s))) : (-1 < (l = qt.getGeometry(u)).type.indexOf("Line") && g && this._isLineInPoly(l, c) || -1 < l.type.indexOf("Polygon") && f && this._isPolyInPoly(l, c)) && n.push(u); d && 0 < (i = Ht.pointsWithinPolygon(i, r)).length && (n = n.concat(i.map(function (e) { return a[e.id] }))) } return n }, Ht.convertWeight = function (e, r, t, n) { var o = { pounds: .45359237, metricTon: 1e3, longTon: 1016, shortTon: 907.18474, kilograms: 1 }; if (r = Ht._normalizeWeightUnit(r), t = Ht._normalizeWeightUnit(t), e = e * o[r] / o[t], "number" == typeof n && 0 <= n) { var i = Math.pow(10, n); e = Math.round(e * i) / i } return e }, Ht._normalizeWeightUnit = function (e) { if (e) { if (e = e.toLowerCase().replace(/(\s|s$)/g, ""), -1 < ["pound", "lb"].indexOf(e)) return "pounds"; if (-1 < ["metricton", "tonne", "t"].indexOf(e)) return "metricTon"; if (-1 < ["longton", "weightton", "w/t", "wt", "imperialton", "displacementton"].indexOf(e)) return "longTon"; if ("shortton" === e) return "shortTon" } return "kilograms" }, Ht._isPolyInPoly = function (e, r) { if ("Polygon" === r.type) { if ("MultiPolygon" !== e.type) return Ct(r, e) || Ut(r, e) || Ut(e, r); for (var t = e, n = void 0, o = 0, i = t.coordinates.length; o < i; o++)if (n = new p.data.Polygon(t.coordinates[o]), Ct(r, n) || Ut(r, n) || Ut(n, r)) return !0; return !1 } var a = r; for (o = 0, i = a.coordinates.length; o < i; o++)if (this._isPolyInPoly(e, new p.data.Polygon(a.coordinates[o]))) return !0; return !1 }, Ht._isLineInPoly = function (e, r) { if ("MultiPolygon" === r.type) { for (var t = r, n = 0, o = t.coordinates.length; n < o; n++)if (this._isLineInPoly(e, new p.data.Polygon(t.coordinates[n]))) return !0; return !1 } if ("MultiLineString" !== e.type) return Ut(r, e) || It(r, e); var i = e, a = void 0; for (n = 0, o = i.coordinates.length; n < o; n++)if (a = new p.data.LineString(i.coordinates[n]), Ut(r, a) || It(r, a)) return !0; return !1 }, Ht.WeightUnits = d.WeightUnits, Ht); function Ht() { } var Jt = ["selectionControl", "routeRangeControl", "truckDimensionsToggle", "truckDimensions", "loadTypeToggle", "travelMode", "selectionArea", "distance", "lengthUnits", "length", "height", "width", "axleWeight", "car", "truck", "pedestrian", "bicycle", "selectOrigin", "time", "travelTime", "distanceUnits", "meters", "miles", "kilometers", "yards", "feet", "weightUnits", "kilograms", "longTon", "metricTon", "pounds", "shortTon", "loadType", "avoid", "search", "cancel", "borderCrossings", "carpools", "ferries", "motorways", "tollRoads", "unpavedRoads", "otherHazmatHarmfulToWater", "USHazmatClass9", "USHazmatClass5", "USHazmatClass6", "USHazmatClass7", "USHazmatClass2", "USHazmatClass8", "USHazmatClass1", "USHazmatClass3", "USHazmatClass4", "circleSelection", "rectangleSelection", "polygonSelection", "routeRangeSelection", "showArea", "traffic", "considerTraffic", "leaveAt", "leaveAtDate", "leaveAtTime", "selectionModes", "selectMode", "avoidToggle", "routeRangeError"], Yt = { en: ["Data selection control", "Route range control. Select origin location by dragging marker with mouse or arrow keys.", "Toggle truck dimension options", "Truck dimensions", "Toggle load type options", "Travel mode", "Selection area", "Distance", "Length units", "Length", "Height", "Width", "Axle weight", "Car", "Truck", "Pedestrian", "Bicycle", "Drag marker to select origin location", "Time", "Travel time (minutes)", "Distance units", "Meters", "Miles", "Kilometers", "Yards", "Feet", "Weight units", "Kilograms", "Long ton", "Metric ton", "Pounds", "Short ton", "Load type", "Avoid", "Search", "Cancel", "Border crossings", "Carpools", "Ferries", "Motorways", "Toll roads", "Unpaved roads", "Harmful to water", "Miscellaneous", "Oxidizers", "Poisons", "Radioactive", "Compressed gas", "Corrosives", "Explosives", "Flammable liquids", "Flammable solids", "Circle selection", "Rectangle selection", "Polygon selection", "Route range selection", "Show area", "Traffic", "Include traffic in calculation", "Leave at", "Leave at date", "Leave at time", "Selection modes", "Select mode", "Toggle avoid options", "Error requesting route range polygon."], af: ["Data seleksie beheer", "Roete wissel beheer. Kies oorsprong plek deur merker te sleep met die muis of pyltjie sleutels.", "Toggle vragmotor dimensie opsies", "vragmotor dimensies", "Toggle tipe vrag opsies", "Reis af", "Seleksie area", "Afstand", "Lengte-eenhede", "lengte", "Hoogte", "wydte", "Axle gewig", "Voertuig", "Vragmotor", "Voetganger", "Fiets", "Sleep merker te kies oorsprong plek", "Tyd", "Reistyd (minute)", "Afstand eenhede", "Meter", "Myl", "Kilometer", "Treë", "Voete", "Gewig eenhede", "Kilogram", "Lang ton", "Metrieke ton", "Pond", "Kort ton", "Tipe vrag", "Verhoed", "Soek", "Kanselleer", "Grensposte", "Carpooler", "Ferries", "Paaie", "Tolpaaie", "Ongeplaveide paaie", "Skadelik vir water", "Diverse", "Oxidant", "Gifstowwe", "Radioaktiewe", "Saamgeperste gas", "Corrosieven", "Plofstof", "Vlambare vloeistowwe", "Vlambare vaste stowwe", "Sirkel seleksie", "Reghoek seleksie", "Veelhoek seleksie", "Reistyd seleksie", "Wys area", "verkeer", "Sluit verkeer in berekening", "verlaat op", "Verlaat op datum", "Verlaat ten tye", "seleksie modes", "Kies modus", "Toggle vermy opsies", "Fout versoek roete reeks veelhoek."], ar: ["تحكم اختيار البيانات", "الطريق تتراوح السيطرة. تحديد أصل المكان عن طريق سحب علامة مع الماوس أو مفاتيح الأسهم.", "تبديل خيارات شاحنة البعد", "أبعاد شاحنة", "تبديل خيارات نوع الحمل", "وضع السفر", "منطقة التحديد", "مسافة", "وحدة طول", "الطول", "ارتفاع", "عرض", "وزن المحور", "سيارة", "شاحنة", "مشاة", "دراجة", "اسحب علامة لتحديد موقع الأصل", "زمن", "السفر عبر الزمن (دقيقة)", "وحدات المسافة", "متر", "اميال", "كم", "ساحات", "أقدام", "وحدات الوزن", "كجم", "طن طويلة", "طن متري", "جنيه أو رطل للوزن", "طن أمريكي", "نوع الحمولة", "تجنب", "بحث", "إلغاء", "المعابر الحدودية", "الانتقال الجماعي", "العبارات", "الطرق السريعة", "الطرق ذات الرسوم", "الطرق غير المعبدة", "تضر المياه", "متنوع", "المؤكسدات", "السموم", "إشعاعي النشاط", "غاز مضغوط", "المواد المسببة للتآكل", "متفجرات", "سوائل قابلة للإشتعال", "المواد الصلبة القابلة للاشتعال", "اختيار دائرة", "اختيار المستطيل", "اختيار المضلع", "السفر اختيار الوقت", "مشاهدة منطقة", "حركة المرور", "تشمل حركة المرور في حساب", "مغادرة عند", "إجازة في التاريخ", "ترك في وقت", "طرق اختيار", "حدد الوضع", "خيارات تجنب تبديل", "خطأ طلب مجموعة الطريق المضلع."], eu: ["Datu aukeraketa kontrol", "Ibilbidea bitartekoa kontrola. Aukeratu jatorria kokapena markatzailea arrastatu sagua edo gezi gakoak.", "Toggle kamioi dimentsio aukerak", "Kamioia dimentsiotan", "Toggle karga mota aukerak", "Bidaiak modua", "Hautaketa inguruan", "Distantzia", "Luzera unitateak", "Luzera", "Altuera", "Zabalera", "Eje pisua", "Car", "Kamioia", "Oinezko", "Bizikleta", "Arrastatu hautatu jatorria kokapena markatzailea", "Ordua", "Bidaia denbora (minutuak)", "Distantzia unitateak", "Metroak", "Mila", "Kilometroak", "Yards", "Oinak", "Pisu-unitateak", "Kilogramo", "Long tonako", "Metric tona", "Pounds", "Tonako short", "Karga-mota", "Ez", "Search", "Utzi", "Border pasabideak", "Carpools", "Ferries", "Autobideak", "Bidesariak", "Unpaved errepide", "Ur kaltegarriak", "Denetarik", "Oxidizers", "Poisons", "Erradiaktiboa", "Konprimitutako gas", "Garratzak", "Lehergailuak", "Likido sukoiak", "Sukoiak solidoen", "Circle aukeraketa", "Rectangle aukeraketa", "Poligono aukeraketa", "Bidaia denboran aukeraketa", "Show inguruan", "Trafikoa", "Besteak beste, kalkulua trafikoa", "tan Utzi", "data Utzi", "berean Utzi", "Hautaketa moduak", "aukeratu modua", "Toggle saihesteko aukera", "Errorea ibilbidea sorta poligono eskatzeko."], bg: ["Данните селекционен контрол", "Път варира контрол. Изберете местоположение произход, като плъзнете маркера с мишката или клавишите със стрелки.", "Превключване на опции камион размери", "размери на камиони", "опции тип товар Превключване", "Начин на пътуване", "област Selection", "разстояние", "Дължина единици", "дължина", "височина", "широчина", "ос на тегло", "Кола", "Камион", "Пешеходец", "велосипед", "Drag маркер, за да изберете място произход", "път", "Време за пътуване (минути)", "единици за разстояние", "метри", "Майлс", "Километри", "Ярда", "Крака", "Тегло единици", "Килограми", "Дълъг тон", "Метричен тон", "лири", "Кратък тон", "тип Load", "Да се ​​избегне", "Търсене", "Отказ", "гранични пунктове", "Carpools", "Фериботите", "магистрали", "Платени пътища", "Неасфалтирани пътища", "Вреден за вода", "Разни", "Окислители", "Отрови", "радиоактивен", "Сгъстен газ", "Корозивни", "Експлозиви", "запалими течности", "твърди запалими вещества", "подбор Circle", "избор на правоъгълник", "подбор Polygon", "избор Времето за пътуване", "Покажи област", "Трафик", "Включи трафик в изчисление", "Оставете най-", "Оставете дата", "Оставете време", "режими за избор на", "Изберете режим", "опции Превключване избягвайте", "Грешка с искане гама маршрут многоъгълник."], zh: ["数据选择控制", "道路范围控制。通过拖动标记用鼠标选择原点位置或箭头键。", "切换卡车尺寸选项", "卡车尺寸", "切换负载类型选项", "旅游模式", "选择区域", "距离", "长度单位", "长度", "高度", "宽度", "轴重", "汽车", "卡车", "行人", "自行车", "拖动标记来选择原点位置", "时间", "旅行时间（分钟）", "距离单位", "米", "万里", "公里", "码", "脚", "重量单位", "公斤", "英吨", "公吨", "英镑", "短吨", "负载类型", "避免", "搜索", "取消", "边境口岸", "合乘", "渡轮", "高速公路", "收费公路", "土路", "有害水", "杂", "氧化剂", "毒药", "放射性的", "压缩气体", "腐蚀性物质", "炸药", "易燃液体", "易燃固体", "圆选择", "矩形选择", "多边形选择", "旅行时间选择", "展示区", "交通", "包括计算流量", "在离开", "在留日期", "在留时间", "选择模式", "选择模式", "切换避免选项", "错误请求道路范围的多边形。"], hr: ["Podaci kontrola za odabir", "Ruta rasponu kontrole. Odaberite podrijetlo položaj povlačenjem marker s mišem ili tipke sa strelicama.", "Prebaci opcije dimenzija kamiona", "dimenzije kamiona", "Prebaci opcije tipa opterećenja", "Način putovanja", "Područje za odabir", "Udaljenost", "Duljina jedinice", "dužina", "Visina", "Širina", "osovinsko opterećenje", "Automobil", "Kamion", "Pješak", "Bicikl", "Povucite marker za odabir lokacije porijekla", "Vrijeme", "Vrijeme putovanja (minuta)", "Udaljenost jedinice", "Metara", "Milja", "Kilometara", "Yards", "Noge", "Težina jedinice", "Kilograma", "Metrička tona", "Metričkih tona", "Funti", "Kratki tona", "Vrsta opterećenja", "Izbjegavajte", "traži", "Otkazati", "Granični prijelazi", "Carpools", "Trajekti", "Autoceste", "Cesta s naplatom cestarine", "Makadam", "Štetno za vodu", "Razni", "Oxidizers", "Otrovi", "Radioaktivan", "Komprimirani plin", "Koroziju", "Eksplozivi", "Zapaljive tekućine", "Zapaljive krute tvari", "Izbor krug", "Izbor pravokutnik", "Izbor poligon", "Putovanja odabir vremena", "Prikaži područje", "Promet", "Uključi promet u izračun", "Ostavite na", "Ostavite na dan", "Ostavite na vrijeme", "načini odabira", "Odaberite način", "Prebaci opcije Izbjegavajte", "Pogreška traži raspon put poligon."], cs: ["Ovládání výběr dat", "Trasa rozsah kontroly. Nalezení původu tažením značky s myší nebo šipkami.", "Toggle možnosti rozměr truck", "rozměry návěsové", "možnosti typu zatížení Toggle", "Režim cesty", "Volba area", "Vzdálenost", "Délkových jednotek", "Délka", "Výška", "Šířka", "Zatížení nápravy", "Auto", "Nákladní auto", "Pěší", "Jízdní kolo", "Drag značka pro výběr místa původu", "Čas", "Cestovní čas (minuty)", "Vzdálenost jednotky", "Metry", "Miles", "Kilometry", "Yards", "Chodidla", "Jednotky hmotnosti", "Kilogramů", "Long ton", "Metrická tuna", "Liber", "Short ton", "Typ zátěže", "Vyhýbat se", "Vyhledávání", "Zrušení", "Hraniční přechody", "Carpools", "Trajekty", "Dálnic", "Placené silnice", "Nezpevněné cesty", "Škodlivá pro vodu", "Smíšený", "Oxidizers", "Jedy", "Radioaktivní", "Stlačený plyn", "Žíraviny", "Výbušniny", "Hořlavé kapaliny", "Hořlavé tuhé látky", "Volba circle", "Obdélník výběru", "Volba polygon", "Volba cesty", "Show area", "Provoz", "Zahrnout provoz ve výpočtu", "odejít", "Nechat datu", "Zanechat v době", "režimy pro výběr", "Vyberte režim", "možnosti Toggle Vyhněte", "Chyba při vyžádání rozsah trasa polygonu."], da: ["Data, udvælgelse kontrol", "Rute spænder kontrol. Vælg oprindelsesbetegnelse ved at trække markøren med musen eller piletasterne.", "Toggle lastbil dimension muligheder", "truck dimensioner", "Toggle belastning typen muligheder", "Travel-tilstand", "Udvælgelse område", "Afstand", "Længde enheder", "Længde", "Højde", "Bredde", "aksel vægt", "Bil", "Lastbil", "Fodgænger", "Cykel", "Træk markøren til at vælge oprindelsesbetegnelse", "Tid", "Rejsetid (minutter)", "Distance enheder", "Målere", "Miles", "Kilometer", "Yards", "Feet", "Vægtenheder", "Kg", "Lang ton", "Ton", "Pund", "Short ton", "Belastningstype", "Undgå", "Søg", "Afbestille", "Grænseovergange", "Carpools", "Færger", "Motorveje", "Betalingsveje", "Grusveje", "Skadelig for vand", "Diverse", "Iltningsmidler", "Giftstoffer", "Radioaktiv", "Komprimeret gas", "Ætsende", "Sprængstoffer", "Brandfarlige væsker", "Brandfarlige faste stoffer", "Udvælgelse circle", "Markeringsrektangel", "Udvælgelse polygon", "Rejsetid udvælgelse", "Vis område", "Trafik", "Medtag trafik i beregning", "Efterlad på", "Efterlad på dato", "Efterlad på tid", "tilstande Selection", "Vælg tilstand", "Toggle Undgå muligheder", "Fejl anmoder rute rækkevidde polygon."], nl: ["Gegevens selectie controle", "Route instelbaar detectiebereik. Selecteer herkomst door marker te slepen met de muis of de pijltoetsen.", "Toggle truck dimensie opties", "truck afmetingen", "Toggle lasttype opties", "Reismodus", "Selectiegebied", "Afstand", "Lengte eenheden", "Lengte", "Hoogte", "Breedte", "asdruk", "Auto", "Vrachtwagen", "Voetganger", "Fiets", "Sleep marker te selecteren herkomst", "Tijd", "Reistijd (minuten)", "Afstand units", "Meters", "Mijlen", "Kilometers", "Yards", "Voeten", "Gewichtseenheden", "Kilogram", "Engelse pond", "Ton", "Pounds", "Short ton", "Lasttype", "Vermijd", "Zoeken", "Annuleer", "Grensovergangen", "Carpools", "Ferries", "Snelwegen", "Tolwegen", "Onverharde wegen", "Schadelijk voor in het water", "Diversen", "Oxidatiemiddelen", "Vergiftigingen", "Radioactieve", "Gecomprimeerd gas", "Bijtende stoffen", "Explosieven", "Ontvlambare vloeistoffen", "Brandbare vaste stoffen", "Circle selectie", "Rectangle selectie", "Polygon selectie", "Reistijd selectie", "Show area", "Verkeer", "Inclusief het verkeer in de berekening", "Vertrekken om", "Laat op de datum", "Laat op het moment", "selectie modi", "Selecteer modus", "Toggle vermijden opties", "Fout bij het aanvragen route bereik veelhoek."], et: ["Andmed juhtnupus", "Marsruudi ulatuvad kontrolli. Valige päritolu asukoha lohistades marker hiire või nooleklahvidega.", "Lülita veoauto mõõde võimalusi", "Truck mõõtmed", "Lülita koormuse tüüp võimalusi", "Reisirežiim", "Valikualal", "Kaugus", "Pikkus üksused", "pikkus", "kõrgus", "laius", "teljekoormus", "Auto", "Veoauto", "Jalakäija", "Jalgratas", "Drag marker valige päritolu asukoha", "Aeg", "Travel aeg (minutites)", "Kaugus üksused", "Meetri", "Miili", "Kilomeetri", "Yards", "Jalad", "Kaalu ühikud", "Kilogrammi", "Pikk tonn", "Tonni", "Nael", "Lühike tonn", "Load tüüp", "Vältima", "Otsing", "Tühistama", "Piiriületuste", "Carpools", "Ferries", "Kiirteed", "Toll teed", "Katteta teed", "Kahjulik vees", "Muu", "Oksüdandid", "Mürgid", "Radioaktiivne", "Surugaasi", "Söövitavaid", "Lõhkeained", "Tuleohtlikud vedelikud", "Tuleohtlikud tahked ained", "Circle valiku", "Ristkülik valikut", "Polygon valikut", "Travel aeg valikut", "Näita piirkond", "liiklus", "Kaasa liikluse arvutus", "Jäta", "Jäta kuupäev", "Jäta ajal", "valikurežiimid", "Valige režiim", "Lülita vältida võimalusi", "Viga kutse marsruudi valikut hulknurk."], fi: ["Tietojen valinta ohjaus", "Reitti alueen säätö. Valitse alkuperä sijaintia vetämällä merkki hiirellä tai nuolinäppäimillä.", "Toggle kuorma ulottuvuus vaihtoehtoja", "Truck mitat", "Toggle kuormitustyyppi vaihtoehtoja", "Reitin tyyppi", "Valinta-alue", "Etäisyys", "Pituus yksikköä", "Pituus", "Korkeus", "Leveys", "akselipaino", "Auto", "Kuorma-auto", "Jalankulkija", "Polkupyörä", "Vedä merkintää valitaksesi alkuperää sijainti", "Aika", "Matka-aika (minuuttia)", "Mittayksiköt", "Mittarit", "Mailia", "Kilometriä", "Yards", "Jalat", "Painoyksikköä", "Kilogrammaa", "Pitkä tonni", "Tonni", "Puntaa", "Lyhyt tonni", "Kuormitustyyppi", "Välttää", "Hae", "Peruuttaa", "Rajanylitysten", "Carpools", "Lautat", "Moottoritiet", "Tietullit", "Päällystämättömät tiet", "Vahingoittaa vesistöjä", "Sekalainen", "Hapettimet", "Myrkyt", "Radioaktiivinen", "Puristettu kaasu", "Syövyttäviä aineita", "Räjähteet", "Helposti syttyvät nesteet", "Syttyvät kiinteät aineet", "Circle valinta", "Suorakaide valinta", "Monikulmio valinta", "Matka-aika valinta", "Näyttelyalue", "liikenne", "Sisällyttää liikenteen laskenta", "jätä", "Jätä ajankohtana", "Jätä hetkellä", "valinta tilaa", "Valitse tila", "Toggle välttää vaihtoehtoja", "Virhe pyydettäessä reitti alue monikulmio."], fr: ["Contrôle de sélection des données", "Route de la chaîne de contrôle. Sélectionnez l'emplacement d'origine en faisant glisser le marqueur avec les touches souris ou les flèches.", "Basculer options de dimension de camion", "Dimensions de camion", "Basculer options de type de charge", "Mode voyage", "Zone de sélection", "Distance", "Les unités de longueur", "Longueur", "la taille", "Largeur", "poids de l'essieu", "Voiture", "Un camion", "Piéton", "Vélo", "Faites glisser marqueur de sélection d'emplacement d'origine", "Temps", "Temps de voyage (minutes)", "Unités de distance", "Mètres", "Miles", "Kilomètres", "Yards", "Pieds", "Unités de poids", "Kilogrammes", "Tonne longue", "Tonne", "Livres sterling", "Tonne courte", "Type de charge", "Éviter", "Chercher", "Annuler", "Les passages frontaliers", "Covoiturages", "Ferries", "Motorways", "Les routes à péage", "Des routes non pavées", "Nocif pour l'eau", "Divers", "Comburants", "Poisons", "Radioactif", "Gaz compressé", "Corrosives", "Explosifs", "Liquides inflammables", "Matières solides inflammables", "Sélection cercle", "Sélection rectangle", "Sélection polygon", "Sélection du temps voyage", "Afficher la zone", "Circulation", "Inclure le trafic dans le calcul", "Quitte à", "Laisser à la date", "Laissez au temps", "Modes de sélection", "Sélectionnez le mode", "Basculer éviter les options", "Erreur demandant polygone de gamme d'itinéraire."], gl: ["de mando de selección de datos", "Route varían control. Seleccione a localización orixe arrastrando marcador co rato ou as frechas.", "Cambiar opcións de dimensión camión", "dimensións camión", "opcións de tipo de carga de alternancia", "Modo de viaxe", "Área de selección", "Distancia", "Unidades de lonxitude", "lonxitude", "altura", "ancho", "peso por eixe", "Coche", "Camión", "Peón", "Bicicleta", "Arrastre marcador para seleccionar o lugar de orixe", "Tempo", "O tempo de viaxe (minutos)", "Unidades de distancia", "Metros", "Miles", "Quilómetros", "Yards", "Pés", "Unidades de peso", "Quilogramos", "Tonelada longa", "Tonelada métrica", "Libras", "Tonelada corta", "Tipo de carga", "Evite", "Buscar", "Cancelar", "Postos de fronteira", "Carpools", "Ferries", "Autoestradas", "Estradas con peaxe", "Estradas non pavimentadas", "Prexudicial para a auga", "Diverso", "Oxidantes", "Velenos", "Radioactivo", "Gas comprimido", "Corrosivos", "Explosivos", "Líquidos inflamables", "Sólidos inflamables", "Selección círculo", "Selección rectángulo", "Selección polígono", "Selección tempo de viaxe", "Amosar área", "tráfico", "Inclúen o tráfico no cálculo", "deixe polo", "Deixar a data", "Deixe o tempo", "modos de selección", "Seleccione o modo de", "opcións Evitar alternancia", "Erro solicitando gama ruta polígono."], de: ["Datenauswahlsteuerung", "Route reiche Kontrolle. Wählt Herkunft Standort durch Markierung mit der Maus ziehen oder Pfeiltasten.", "Toggle LKW Dimension Optionen", "Abmessungen des Staplers", "Toggle-Lasttyp-Optionen", "Reisemodus", "Auswahlbereich", "Entfernung", "Längeneinheiten", "Länge", "Höhe", "Breite", "Achsgewicht", "Wagen", "Lkw", "Fußgänger", "Fahrrad", "Ziehen Marker zu wählen Herkunft Standort", "Zeit", "Reisezeit (minuten)", "Entfernungseinheiten", "Meter", "Meilen", "Kilometer", "Yards", "Füße", "Gewichtseinheiten", "Kg", "Lange tonne", "Tonne", "Pounds", "Short ton", "Lastart", "Vermeiden", "Suche", "Stornieren", "Grenzübergänge", "Carpools", "Fähren", "Autobahnen", "Gebührenpflichtige straßen", "Straßen ohne belag", "Schädlich für wasser", "Verschiedenes", "Oxidizers", "Vergiftet", "Radioaktiv", "Komprimiertes gas", "Ätzende", "Explosive", "Entflammbare flüssigkeiten", "Brennbare feststoffe", "Kreis auswahl", "Rectangle auswahl", "Polygon-auswahl", "Reisezeit auswahl", "Show-bereich", "Der Verkehr", "Fügen Sie Verkehr in der Berechnung", "Verlassen um", "Lassen Sie am Datum", "Lassen Sie zum Zeitpunkt", "Auswahlmodi", "Auswahlmodus", "Toggle vermeiden Optionen", "Fehler Route Bereich Polygon anfordert."], el: ["ελέγχου επιλογής δεδομένων", "Route εύρος ελέγχου. Επιλέξτε την τοποθεσία προέλευσης σύροντας δείκτη με το ποντίκι ή τα πλήκτρα βέλους.", "Εναλλαγή επιλογές διάσταση φορτηγό", "διαστάσεις φορτηγών", "Εναλλαγή επιλογές τύπου φορτίου", "Λειτουργία ταξίδια", "Περιοχή επιλογής", "Απόσταση", "Μονάδες μήκους", "Μήκος", "Υψος", "Πλάτος", "βάρος ανά άξονα", "Αυτοκίνητο", "Φορτηγό", "Πεζός", "Ποδήλατο", "δείκτη σύρετε για να επιλέξετε την τοποθεσία προέλευσης", "Χρόνος", "Η διάρκεια του ταξιδιού (λεπτά)", "Μονάδες απόστασης", "Μετρητές", "Miles", "Χιλιόμετρα", "Ναυπηγεία", "Πόδια", "Μονάδες βάρους", "Κιλά", "Long τόνο", "Μετρικός τόνος", "Λίρες", "Σύντομη τόνο", "Τύπος φορτίου", "Αποφύγει", "Αναζήτηση", "Ματαίωση", "Σημεία διέλευσης των συνόρων", "Αυτοκίνητα", "Πλοία", "Αυτοκινητόδρομοι", "Δρόμοι με διόδια", "Μη ασφαλτοστρωμένοι δρόμοι", "Επιβλαβές για το νερό", "Διάφορα", "Οξειδωτικά", "Δηλητήρια", "Ραδιενεργός", "Συμπιεσμένο φυσικό αέριο", "Διαβρωτικά", "Εκρηκτικά", "Εύφλεκτα υγρά", "Εύφλεκτα στερεά", "Επιλογή κύκλος", "Επιλογή ορθογώνιο", "Επιλογή πολύγωνο", "Επιλογή ταξίδι στο χρόνο", "Εμφάνιση περιοχή", "ΚΙΝΗΣΗ στους ΔΡΟΜΟΥΣ", "Συμπεριλάβετε κυκλοφορίας κατά τον υπολογισμό", "Αφήστε σε", "Αφήστε κατά την ημερομηνία", "Αφήστε κατά το χρόνο", "τρόποι επιλογής", "Επιλέξτε τη λειτουργία", "επιλογές αποφεύγουν Εναλλαγή", "Σφάλμα ζητώντας εύρος διαδρομής πολύγωνο."], hi: ["डाटा चयन नियंत्रण", "मार्ग लेकर नियंत्रण। माउस के साथ मार्कर खींचकर मूल स्थान का चयन करें या तीर कुंजियों का।", "टॉगल ट्रक आयाम विकल्प", "ट्रक आयाम", "टॉगल लोड प्रकार के विकल्प", "यात्रा मोड", "चुनाव क्षेत्र", "दूरी", "लंबाई इकाइयों", "लंबाई", "ऊंचाई", "चौड़ाई", "एक्सल वजन", "गाड़ी", "ट्रक", "पैदल यात्री", "साइकिल", "चुनिंदा मूल स्थान के लिए मार्कर को खींचें", "समय", "यात्रा के समय (मिनट)", "दूरी की इकाइयां", "मीटर", "मीलों", "किलोमीटर", "गज", "पैर का पंजा", "भार इकाइयों", "किलोग्राम", "लंबा टन", "मैट्रिक टन", "पाउंड", "लघु टन", "लोड प्रकार", "बचें", "खोज", "रद्द करना", "सीमा क्रॉसिंगों", "कारपूल", "घाट", "सड़कों", "टोल की सड़के", "कच्ची सड़कें", "पानी के लिए हानिकारक", "विविध", "ऑक्सीडाइजर", "जहर", "रेडियोधर्मी", "संपीडित गैस", "संक्षारक", "विस्फोटक", "ज्वलनशील तरल", "ज्वलनशील ठोस", "सर्किल चयन", "आयत चयन", "बहुभुज चयन", "यात्रा के समय चयन", "दिखाएँ क्षेत्र", "यातायात", "गणना में ट्रैफ़िक शामिल करें", "पर छोड़ दें", "की तारीख में छोड़ दो", "समय में छोड़ दो", "चयन मोड", "मोड का चयन करें", "टॉगल से बचने के विकल्प", "मार्ग रेंज बहुभुज का अनुरोध करते हुए त्रुटि।"], hu: ["Adatválasztó ellenőrzés", "Útvonal tartomány ellenőrzés. Válassza származási helyet húzással marker egeret vagy a nyilakkal.", "Toggle teherautó dimenzió lehetőségek", "Truck méretek", "Toggle terhelés típusától lehetőségek", "Utazási mód", "Felvételi terület", "Távolság", "Hosszmértékegységet", "Hossz", "Magasság", "Szélesség", "tengelyterhelés", "Autó", "Kamion", "Gyalogos", "Kerékpár", "Jelölő húzása a kezdőhely kijelöléséhez", "Idő", "Az utazási idő (perc)", "Távolságegység", "Méter", "Mérföld", "Kilométerek", "Yard", "Feet", "Tömegegységei", "Kilogramm", "Long ton", "Metrikus tonna", "Font", "Short ton", "Terhelés típusa", "Elkerül", "Keresés", "Megszünteti", "Határátkelők", "Carpools", "Kompok", "Autópályák", "Fizetős utak", "Földutakat", "Ártalmas a vízi", "Vegyes", "Oxidálószerek", "Mérgek", "Radioaktív", "Sűrített gáz", "Korroziv", "Robbanóanyagok", "Gyúlékony folyadékok", "Gyúlékony szilárd anyagok", "Kör kiválasztása", "Téglalap kiválasztás", "Sokszög kiválasztás", "Az utazási idő kiválasztása", "Megjelenítése terület", "Forgalom", "Tartalmazza a forgalom számítás", "Hagyja a", "Hagyja a dátum", "Hagyja időpontban", "Felvételi módok", "Select módban", "Toggle elkerül lehetőségek", "Hiba az útvonalon tartományban sokszög."], id: ["kontrol seleksi data", "Route berkisar kontrol. Pilih lokasi asal dengan menyeret penanda dengan mouse atau tombol panah.", "Beralih pilihan dimensi truk", "dimensi truk", "Beralih jenis beban pilihan", "Modus travel", "Area seleksi", "Jarak", "Unit panjang", "Panjangnya", "Tinggi", "Lebar", "berat poros", "Mobil", "Truk", "Pejalan kaki", "Sepeda", "Seret penanda untuk memilih lokasi asal", "Waktu", "Perjalanan waktu (menit)", "Unit jarak", "Meter", "Miles", "Kilometer", "Yards", "Kaki", "Unit berat", "Kilogram", "Panjang ton", "Metrik ton", "Pounds", "Singkat ton", "Jenis beban", "Menghindari", "Cari", "Membatalkan", "Penyeberangan perbatasan", "Carpools", "Feri", "Raya", "Jalan tol", "Jalan beraspal", "Berbahaya untuk air", "Bermacam-macam", "Oksidasi", "Racun", "Radioaktif", "Gas terkompresi", "Corrosives", "Bahan peledak", "Cairan mudah terbakar", "Padatan mudah terbakar", "Seleksi lingkaran", "Seleksi persegi panjang", "Seleksi polygon", "Perjalanan pemilihan waktu", "Tampilkan daerah", "Lalu lintas", "Sertakan lalu lintas dalam perhitungan", "Tinggalkan di", "Tinggalkan pada tanggal", "Tinggalkan saat", "mode seleksi", "pilih modus", "Pilihan menghindari beralih", "Kesalahan meminta berbagai rute poligon."], it: ["selettore dati", "Percorso campo di regolazione. Seleziona posizione di origine trascinando marcatore con il mouse o le frecce.", "Toggle opzioni di dimensione camion", "dimensioni camion", "Toggle opzioni tipo di carico", "Modalità di viaggio", "Area di selezione", "Distanza", "Unità di lunghezza", "Lunghezza", "Altezza", "Larghezza", "peso per asse", "Macchina", "Camion", "Pedone", "Bicicletta", "marcatore Trascinare per selezionare posizione di origine", "Tempo", "Il tempo di percorrenza (minuti)", "Unità di distanza", "Metri", "Miglia", "Chilometri", "Yards", "Piedi", "Unità di peso", "Chilogrammi", "Tonnellata lunga", "Tonnellata", "Sterline", "Breve ton", "Tipo di caricamento", "Evitare", "Ricerca", "Annulla", "Valichi di frontiera", "Carpools", "Traghetti", "Autostrade", "Strade a pedaggio", "Strade sterrate", "Nocivo per l'acqua", "Miscellaneo", "Ossidanti", "Veleni", "Radioattivo", "Gas compresso", "Corrosivi", "Esplosivi", "Liquidi infiammabili", "Solidi infiammabili", "Selezione circle", "Rettangolo di selezione", "Selezione poligono", "Selezione del tempo di viaggio", "Visualizza zona", "Traffico", "Includi traffico di calcolo", "Partiamo alle", "Lasciare alla data", "Lasciare al momento", "modalità di selezione", "Selezionare la modalità", "Opzioni Evita Toggle", "Errore nella richiesta di gamma percorso poligono."], ja: ["データ選択制御", "ルートの範囲を制御します。マウスでマーカーをドラッグして元の場所を選択するか、矢印キーを。", "トグルトラックの寸法オプション", "トラック寸法", "トグルロードタイプのオプション", "トラベルモード", "選択エリア", "距離", "長さの単位", "長さ", "高さ", "幅", "軸荷重", "車", "トラック", "歩行者", "自転車", "原点の場所を選択するためのドラッグマーカー", "時間", "移動時間（分）", "距離の単位", "メーター", "マイル", "キロ", "ヤード", "足", "重量単位", "キログラム", "ロングトン", "メトリックトン", "ポンド", "ショートトン", "ロードタイプ", "避ける", "探す", "キャンセル", "国境通過", "相乗り", "フェリー", "高速道路", "有料道路", "未舗装の道路", "水に有害", "雑多", "酸化剤", "毒", "放射性", "圧縮ガス", "腐食", "爆発物", "可燃性の液体", "可燃性固体", "サークルの選択", "矩形選択", "ポリゴンの選択", "所要時間の選択", "表示エリア", "トラフィック", "計算にトラフィックを含めます", "休暇で", "日のまま", "時のまま", "選択モード", "モードを選択します", "トグル回避オプション", "ルートの範囲のポリゴンを要求するエラー。"], kk: ["Деректер таңдау бақылау", "Маршрут диапазоны бақылау. тінтуірмен маркер сүйреу арқылы шығу орынды таңдаңыз немесе көрсеткі пернелерін.", "Toggle жүк өлшемі параметрлері", "жүк өлшемдері", "Toggle жүктеме түрі параметрлері", "Саяхат режимі", "Таңдау ауданы", "Қашықтық", "Ұзындығы бірлік", "ұзындық", "биіктік", "ені", "ось салмағы", "Машина", "Жүк", "Жаяу", "Велосипед", "шығу орналасуын таңдау үшін сүйреңіз маркер", "Уақыт", "Саяхат уақыты (минут)", "Қашықтық бірліктері", "Метр", "Miles", "Шақырым", "Аулалары", "Feet", "Салмағы бірлік", "Кг", "Ұзақ тонна", "Метрикалық тонна", "Фунт", "Қысқа тонна", "Load түрі", "Аулақ", "іздеу", "Күшін жою", "Шекаралық өткелдерде", "Автопулов", "Паромдар", "Автомагистральдар", "Ақылы жолдар", "Топырақты жолдар", "Суға зиянды", "Әр түрлі", "Окислителей", "Улар", "Радиоактивті", "Сығылған газ", "Ыдыратуға", "Жарылғыш заттар", "Тұтанғыш сұйықтықтар", "Тұтанғыш қатты заттар", "Circle таңдау", "Rectangle таңдау", "Көпбұрыш таңдау", "Саяхат уақыты таңдау", "Көрсету ауданы", "Трафик", "есептеу трафикті қамтиды", "Қалдыру кезінде", "күнгі Қалдыру", "уақытта Қалдыру", "таңдау режимдері", "режимін таңдаңыз", "Toggle аулақ опциялары", "маршрут ауқымы көпбұрыштың салушы қатесі."], ko: ["데이터 선택 컨트롤", "경로 제어를 다양합니다. 마우스로 마커를 드래그하여 원점 위치를 선택하거나 화살표 키를.", "토글 트럭 차원 옵션", "트럭 차원", "전환 부하 유형 옵션", "여행 모드", "선택 영역", "거리", "길이 단위", "길이", "신장", "폭", "차축 무게", "차", "트럭", "보행자", "자전거", "선택 원점 위치로 드래그 마커", "시각", "소요 시간 (분)", "거리 단위", "미터", "마일", "킬로미터", "야드", "피트", "무게 단위", "킬로그램", "영국 톤", "메트릭 톤", "파운드", "짧은 톤", "로드 형", "기피", "검색", "취소", "국경", "카풀", "페리", "고속도로", "유료 도로", "비포장 도로", "물에 유해", "여러 가지 잡다한", "산화제", "독", "방사성", "압축 가스", "부식제", "폭발물", "인화성 액체", "가연성 고체", "서클 선택", "사각형 선택", "다각형 선택", "여행 시간 선택", "표시 영역", "교통", "계산 트래픽을 포함", "에 남겨주세요", "날짜에 남겨주세요", "한 번에 남겨주세요", "선택 모드", "선택 모드", "전환 피할 옵션", "경로 범위 다각형을 요청하는 오류가 발생했습니다."], es: ["control de selección de datos", "Ruta rango de control. Seleccionar ubicación de origen arrastrando marcador con el ratón o las teclas de flecha.", "Toggle opciones de dimensión camión", "dimensiones de la carretilla", "Toggle opciones de tipo de carga", "El modo de viaje", "Área de selección", "Distancia", "Las unidades de longitud", "Longitud", "Altura", "Anchura", "peso por eje", "Coche", "Camión", "Peatonal", "Bicicleta", "Arrastre marcador para seleccionar la ubicación de origen", "Hora", "El tiempo de viaje (minutos)", "Unidades de distancia", "Metros", "Miles", "Kilómetros", "Yardas", "Pies", "Unidades de peso", "Kilogramos", "Tonelada larga", "Tonelada métrica", "Libras", "Tonelada corta", "Tipo de carga", "Evitar", "Buscar", "Cancelar", "Cruces fronterizos", "Comparte coche", "Transbordadores", "Autopistas", "Carreteras de peaje", "Carreteras sin pavimentar", "Contaminación de las aguas", "Diverso", "Oxidantes", "Venenos", "Radioactivo", "Gas comprimido", "Corrosivos", "Explosivos", "Líquidos inflamables", "Sólidos inflamables", "Selección círculo", "Rectángulo de selección", "De selección poligonal", "Selección del tiempo de viaje", "Mostrar área", "Tráfico", "Incluir en el cálculo del tráfico", "Dejar en", "Deja en la fecha", "Deja en el momento", "modos de selección", "Seleccionar modo", "Evita opciones de alternar", "Error al solicitar polígono gama ruta."], lv: ["Datu atlase kontrole", "Route svārstās kontroli. Izvēlieties izcelsmes vietu, velkot marķieri ar peli vai bultu taustiņus.", "Pārslēgt kravas dimensija iespējas", "kravas izmēri", "Pārslēgt slodze tips iespējas", "Travel režīms", "Atlase platība", "Attālums", "Garums vienības", "garums", "augstums", "platums", "ass svars", "Auto", "Smagā mašīna", "Gājējs", "Velosipēds", "Velciet marķieri uz izvēlieties izcelsmes vietu", "Laiks", "Brauciena laiks (minūtes)", "Attāluma mērvienības", "Metri", "Miles", "Kilometri", "Jardi", "Pēdas", "Svara vienības", "Kilogrami", "Long ton", "Metriskā tonna", "Mārciņas", "Īsā tonna", "Slodzes tips", "Izvairīties", "Meklēt", "Atcelt", "Robežšķērsošana", "Carpools", "Prāmji", "Automaģistrāles", "Maksas ceļi", "Ceļi bez", "Kaitīgs ūdens", "Dažādi", "Oksidētāji", "Indes", "Radioaktīvs", "Saspiesta gāze", "Kodīgas", "Sprāgstvielas", "Viegli uzliesmojošus šķidrumus", "Uzliesmojošas cietas vielas", "Circle atlase", "Taisnstūris atlase", "Poligons atlase", "Braukšanas laiks atlase", "Rādīt platība", "satiksme", "Iekļaut satiksmi aprēķinos", "Atstājiet at", "Atstājiet uz datuma", "Atstājiet laikā", "Atlases režīmi", "Izvēlieties režīmu", "Pārslēgt izvairieties iespējas", "Kļūda pieprasot maršruts diapazons poligonu."], lt: ["Duomenų atranka kontrolė", "Maršruto svyruoja kontrolę. Pasirinkite kilmės vietą vilkdami žymeklį su pele arba rodyklių klavišais.", "Toggle sunkvežimis dimensija galimybės", "sunkvežimių matmenys", "Toggle Krovinio tipas galimybės", "Keliavimo būdas", "Pasirinkimas plotas", "Atstumas", "Ilgis vienetai", "ilgis", "aukštis", "plotis", "ašies svoris", "Automobilis", "Sunkvežimis", "Pėsčiasis", "Dviratis", "Vilkite žymeklį pasirinkite kilmės vietos", "Laikas", "Kelionės trukmė (min)", "Atstumas vienetai", "Metrų", "Mylios", "Kilometrų", "Km", "Kojos", "Masės vienetai", "Kilogramų", "Ilgas tona", "Metrinės tonos", "Svarų", "Trumpas tona", "Krovinio tipas", "Venkite", "Paieška", "Atšaukti", "Sienos kirtimo", "Keliones automobiliu", "Keltai", "Greitkeliai", "Apmokestinti keliai", "Negrįsti keliai", "Žalingas vandens", "Jvairus", "Oksidatoriais", "Nuodai", "Radioaktyvus", "Suspaustos dujos", "Korozinės", "Sprogmenys", "Degūs skysčiai", "Degiosios kietosios", "Draugų pasirinkimas", "Stačiakampis pasirinkimas", "Daugiakampis pasirinkimas", "Kelionės laikas pasirinkimo", "Rodyti plotas", "eismas", "Įtraukti eismo apskaičiavimo", "Palikite bent", "Palikite bent dieną", "Palikite metu", "atrankos būdai", "Pasirinkite režimą", "Toggle Venkite galimybės", "Klaida prašančioji maršrutas diapazonas daugiakampis."], ms: ["Data kawalan pilihan", "Route berkisar kawalan. Pilih lokasi asal dengan menyeret penanda dengan tetikus atau kekunci anak panah.", "Togol pilihan trak dimensi", "dimensi trak", "Togol pilihan jenis beban", "Mod perjalanan", "Kawasan pilihan", "Jarak", "Unit panjang", "Negara", "tinggi", "lebar", "berat gandar", "Kereta", "Trak", "Pejalan kaki", "Basikal", "Seret penanda untuk pilih lokasi asal", "Masa", "Masa perjalanan (minit)", "Unit jarak", "Meter", "Batu", "Kilometer", "Yards", "Kaki", "Unit berat badan", "Kilogram", "Tan panjang", "Tan metrik", "Pounds", "Tan pendek", "Jenis beban", "Elakkan", "cari", "Batal", "Lintasan sempadan", "Perkongsian kereta", "Feri", "Lebuh raya", "Jalan bertol", "Jalan yang tidak berturap", "Berbahaya kepada air", "Pelbagai", "Pengoksida", "Racun", "Radioaktif", "Gas termampat", "Bahan menghakis", "Bahan letupan", "Cecair mudah terbakar", "Pepejal mudah terbakar", "Pilihan circle", "Pilihan segi empat tepat", "Pilihan polygon", "Pilihan masa perjalanan", "Persembahan kawasan", "Traffic", "Termasuk trafik dalam pengiraan", "biarkan sekurang", "Meninggalkan pada tarikh", "Meninggalkan pada masa", "mod pilihan", "pilih mod", "pilihan mengelakkan togol", "Ralat meminta pelbagai laluan poligon."], nb: ["Data utvalg kontroll", "Rute områdekontroll. Velg opprinnelse plassering ved å dra markøren med musen eller piltastene.", "Toggle lastebil dimensjon alternativer", "lastebil dimensjoner", "Toggle belastning typealternativer", "Reisemodus", "Merket område", "Avstand", "Lengdeenheter", "Lengde", "Høyde", "Bredde", "aksellast", "Bil", "Lastebil", "Fotgjenger", "Sykkel", "Dra markøren for å velge opprinnelse plassering", "Tid", "Reisetid (minutter)", "Avstandsenheter", "Meter", "Miles", "Kilometer", "Yards", "Feet", "Vekt enheter", "Kilo", "Long ton", "Metrisk tonn", "Pounds", "Kort ton", "Lasttypen", "Unngå", "Søk", "Avbryt", "Grenseoverganger", "Carpools", "Ferger", "Motorveier", "Bomveier", "Grusveier", "Skadelig for vann", "Diverse", "Oksidanter", "Gift", "Radioaktivt", "Komprimert gass", "Korrosjon", "Sprengstoff", "Brennbare væsker", "Brannfarlige faste stoffer", "Circle utvalg", "Rektangel utvalg", "Polygon utvalg", "Reisetid utvalg", "Vis område", "Trafikk", "Inkluder trafikk i beregningen", "La det", "La det være dato", "La det være tid", "valgmodus", "Velg modus", "Toggle Unngå alternativer", "Feil ber om ruteområde polygon."], pl: ["kontrola selekcji danych", "wynosić droga sterowania. Wybierz lokalizację pochodzenia przeciągając znacznik z myszy lub klawiszy strzałek.", "Przegubowe opcje wymiarowe ciężarówka", "wymiary pojazdów ciężarowych", "Opcje typu obciążenia przerzutowe", "Tryb podróży", "Obszar wyboru", "Dystans", "Jednostki długości", "Długość", "Wysokość", "Szerokość", "nacisk na oś", "Samochód", "Samochód ciężarowy", "Pieszy", "Rower", "Przeciągnij znacznik do wybranej lokalizacji pochodzenia", "Czas", "Czas podróży (minuty)", "Jednostki odległości", "Metrów", "Miles", "Kilometry", "Stocznie", "Stopy", "Jednostki wagowe", "Kilogramy", "Długi ton", "Tonę", "Funtów", "Tona", "Typ obciążenia", "Uniknąć", "Szukaj", "Anuluj", "Przejścia graniczne", "Carpools", "Promy", "Autostrady", "Płatne drogi", "Drogi gruntowe", "Szkodliwy dla wody", "Różne", "Utleniacze", "Trucizny", "Radioaktywny", "Sprężony gaz", "Korozyjne", "Materiały wybuchowe", "Łatwopalne ciecze", "Palne substancje stałe", "Wybór krąg", "Wybór prostokąt", "Wybór wielokąt", "Wybór czasu podróży", "Pokaż obszar", "ruch drogowy", "Obejmują ruch w obliczeniach", "pozostawić na", "Pozostawić na bieżąco", "Pozostawić na czas", "tryby wyboru", "Wybierz tryb", "opcje Unikaj przerzutowe", "Błąd zainteresowanie zakres trasa wielokąt."], pt: ["de comando de selecção de dados", "Route variam controle. Seleccione a localização origem arrastando marcador com o mouse ou as setas.", "Alternar opções de dimensão caminhão", "dimensões caminhão", "opções de tipo de carga de alternância", "Modo de viagem", "Área de seleção", "Distância", "Unidades de comprimento", "comprimento", "Altura", "Largura", "peso por eixo", "Carro", "Caminhão", "Pedestre", "Bicicleta", "Arraste marcador para selecionar o local de origem", "Tempo", "O tempo de viagem (minutos)", "Unidades de distância", "Metros", "Miles", "Quilômetros", "Yards", "Pés", "Unidades de peso", "Quilogramas", "Tonelada longa", "Tonelada metrica", "Libras", "Tonelada curta", "Tipo de carga", "Evitar", "Procurar", "Cancelar", "Postos de fronteira", "Carpools", "Ferries", "Auto-estradas", "Rodovias com pedágio", "Ruas não pavimentadas", "Prejudicial à água", "Diversos", "Oxidantes", "Venenos", "Radioativo", "Gás comprimido", "Corrosivos", "Explosivos", "Líquidos inflamáveis", "Sólidos inflamáveis", "Selecção círculo", "Seleção retângulo", "Seleção polígono", "Seleção tempo de viagem", "Mostrar área", "Tráfego", "Incluem o tráfego no cálculo", "Deixe pelo", "Deixar a data", "Deixe pelo tempo", "modos de seleção", "Modo de seleção", "opções Evitar alternância", "Erro solicitando gama rota polígono."], ro: ["Controlul de selectare a datelor", "Route gama de control. Selectați origine locația trăgând marcatorul cu mouse-ul sau tastele săgeată.", "Toggle opțiuni de dimensiune camion", "dimensiuni camioane", "Opțiunile privind tipul de sarcină Toggle", "Mod de călătorie", "Zona de selecție", "Distanţă", "Unități lungime", "Lungime", "Înălţime", "Lăţime", "greutatea pe osie", "Mașină", "Camion", "Pieton", "Bicicletă", "glisați marcatorul pentru a selecta originea locație", "Timp", "Durata călătoriei (minute)", "Unități de distanță", "Contoare", "Miles", "Kilometri", "Yards", "Picioare", "Unități de greutate", "Kilograme", "Tonă engleză", "Tonă metrică", "Lire", "Tona scurt", "Tipul de încărcare", "Evita", "Căutare", "Anulare", "Trecerile la frontieră", "Carpools", "Feriboturile", "Autostrăzi", "Drumurile cu taxă", "Drumuri nepavate", "Nociv pentru apa", "Diverse", "Oxidanţi", "Otrăvurile", "Radioactiv", "Gaz comprimat", "Corozivi", "Explozivi", "Lichide inflamabile", "Solide inflamabile", "Cercul de selecție", "Selecție dreptunghi", "Selecție poligon", "Selecția timpului de călătorie", "Afișați zona", "Trafic", "Includeți traficul în calcul", "Pleacă la", "Se lasă la data", "Se lasă la timp", "moduri de selecție", "Selectați modul", "opțiuni Evitați Toggle", "Eroare la solicitarea gama de traseu poligon."], ru: ["Контроль выбора данных", "Маршрут диапазон регулирования. Выберите местоположение происхождения путем перетаскивания маркера с помощью мыши или клавиши со стрелками.", "Переключение вариантов измерения грузовика", "размеры грузовых автомобилей", "Параметры типа нагрузки Переключение", "Режим путешествия", "Область выбора", "Расстояние", "Длина блоков", "длина", "Рост", "Ширина", "вес мост", "Машина", "Грузовая машина", "Пешеход", "Велосипед", "Перетащите маркер выбора места происхождения", "Время", "Время в пути (мин)", "Ед.измер.расст", "Метры", "Миль", "Километров", "Ярды", "Ноги", "Вес единицы", "Килограммы", "Длинная тонна", "Метрическая тонна", "Фунты", "Короткая тонна", "Тип нагрузки", "Избегайте", "Поиск", "Отмена", "Пограничные переходы", "Совместное использование автомобиля", "Паромы", "Магистрали", "Платные дороги", "Грунтовые дороги", "Вредный для воды", "Разное", "Окислители", "Яды", "Радиоактивное", "Сжатый газ", "Едкие", "Взрывчатые вещества", "Огнеопасные жидкости", "Легковоспламеняющиеся твердые вещества", "Выбор круг", "Выбор прямоугольник", "Выбор polygon", "Выбор времени для путешествий", "Показать область", "Трафик", "Включите трафик в расчете", "Оставить на", "Оставьте на день", "Оставьте на время", "режимы выбора", "Выбор режима работы", "Варианты остерегайтесь Переключить", "Ошибка запроса диапазона маршрута многоугольник."], sr: ["Подаци контрола избор", "Роуте распону контролу. Селецт порекла локацију превлачењем маркера помоћу миша или стрелица.", "Тоггле камион димензија опције", "Труцк димензије", "Тоггле тип оптерећење опције", "Režim путовања", "Izbor површина", "Раздаљина", "Dužina јединица", "дужина", "висина", "ширина", "оптерећење", "Ауто", "Камион", "Пешак", "Бицикл", "Драг маркер који изаберите порекла локација", "Време", "Време путовања (минута)", "Удаљеност јединице", "Метара", "Миља", "Километара", "Метара", "Стопала", "Тежина јединице", "Килограми", "Метричка тона", "Метричка тона", "Поундс", "Кратко тона", "Тип лоад", "Избегавајте", "Претрага", "Поништити, отказати", "Granični прелази", "Царпоолс", "Трајекти", "Autoputevi", "Путеве са путарином", "Makadami", "Штетан по води", "Остало", "Оксидатори", "Otrovi", "Радиоактиван", "Компримовани гас", "Корозивне", "Eksploziv", "Запаљиве течности", "Запаљиве материје", "Круг избора", "Правоугаоник избор", "Полигон избор", "Време путовања избор", "Схов област", "Саобраћај", "Укључују саобраћај у обрачун", "Оставите у", "Оставите на дан", "Оставите у време", "Селецтион режими", "izaberite режим", "Тоггле Избегавајте опције", "Еррор тражи опсег пут полигон."], sk: ["Ovládanie výber dát", "Trasa rozsah kontroly. Nájdenie pôvodu ťahaním značky s myšou alebo šípkami.", "Toggle možnosti rozmer truck", "rozmery návesovej", "možnosti typu zaťaženia Toggle", "Režim cesty", "Voľba area", "Vzdialenosť", "Dĺžkových jednotiek", "dĺžka", "výška", "šírka", "zaťaženie nápravy", "Auto", "Nákladné auto", "Pešej", "Bicykel", "Presunutím značky vyberte miesto pôvodu", "Čas", "Cestovný čas (minúty)", "Vzdialenosť jednotky", "Metrov", "Miles", "Kilometre", "Yards", "Nohy", "Jednotky hmotnosti", "Kilogramov", "Dlhá tona", "Metrická tona", "Libier", "Krátka tona", "Typ záťaže", "Vyhnite", "Vyhľadávanie", "Zrušiť", "Hraničné priechody", "Carpools", "Trajekty", "Diaľnic", "Spoplatnené cesty", "Nespevnené cesty", "Škodlivá pre vodu", "Zmiešaný", "Oxidizers", "Jedy", "Rádioaktívne", "Stlačený plyn", "Žieraviny", "Výbušniny", "Horľavé kvapaliny", "Horľavé tuhé látky", "Voľba circle", "Obdĺžnik výberu", "Voľba polygón", "Voľba cesty", "Show area", "prevádzka", "Zahrnúť prevádzku vo výpočte", "odísť", "nechať dátume", "Zanechať v čase", "režimy pre výber", "Vyberte režim", "možnosti Toggle Vyhnite", "Chyba pri vyžiadanie rozsah trasa polygónu."], sl: ["Nadzor izbor podatkov", "Pot segajo nadzor. Izberite lokacijo izvora z vlečenjem marker z miško ali puščicami.", "Preklop možnosti tovornjak razsežnosti", "mere za tovorna vozila", "Preklop možnosti tipa obremenitve", "Način potovanja", "Izbira območje", "Razdalja", "Dolžina enote", "dolžina", "Višina", "Premer", "osna obremenitev", "Avto", "Truck", "Pešec", "Koles", "Povlecite marker izberite lokacijo izvora", "Čas", "Potovalni čas (min)", "Enote razdalje", "Metrov", "Milje", "Kilometri", "Yards", "Feet", "Teža enote", "Kilogramov", "Dolga ton", "Tona", "Funtov", "Kratek ton", "Tip bremena", "Izogibajte", "Iskanje", "Preklic", "Mejni prehodi", "Carpools", "Trajekti", "Avtoceste", "Cestninskih cest", "Neasfaltirane ceste", "Škodljiva za vodo", "Ostalo", "Oksidante", "Strupi", "Radioaktivni", "Stisnjen plin", "Jedkih", "Eksplozivi", "Vnetljive tekočine", "Vnetljive trdne snovi", "Izbor krog", "Izbor pravokotnik", "Izbor poligon", "Travel izbor čas", "Pokaži območje", "Traffic", "Vključi prometa v izračun", "pustite", "Pustite na dan", "Pustite času", "načini za izbor", "Izbira načina", "Preklop možnosti odsesavanje", "Napaka zahteva območje pot poligon."], sv: ["Data val kontroll", "Rutt varierar kontroll. Välj ursprung plats genom att dra markören med musen eller piltangenterna.", "Växla lastbil dimension alternativ", "lastbils dimensioner", "Växla alternativ last typ", "Färdmedel", "Markerat område", "Distans", "Längdenheter", "Längd", "Höjd", "Bredd", "axeltryck", "Bil", "Lastbil", "Fotgängare", "Cykel", "Dra markör väljer du ursprung plats", "Tid", "Restid (minuter)", "Avståndsenheter", "Meter", "Miles", "Kilometer", "Yards", "Fötter", "Vikt heter", "Kilogram", "Lång ton", "Metriskt ton", "Pounds", "Short ton", "Lasttyp", "Undvika", "Sök", "Annullera", "Gränsövergångar", "Samåkning", "Färjor", "Motorvägar", "Vägtullar", "Oasfalterade vägar", "Skadliga för vatten", "Diverse", "Oxidationsmedel", "Gifter", "Radioaktiv", "Komprimerad gas", "Frätande", "Explosiva varor", "Brandfarliga vätskor", "Brandfarliga fasta ämnen", "Circle val", "Rektangel val", "Polygon val", "Restid val", "Visa area", "Trafik", "Inkludera trafiken i beräkning", "Lämna vid", "Lämna betalning", "Lämna vid tiden", "urval lägen", "Välj läge", "Växla Undvik alternativ", "Fel begära ruttområde polygon."], th: ["การควบคุมตัวเลือกข้อมูล", "เส้นทางการควบคุมช่วง เลือกสถานที่กำเนิดโดยการลากเครื่องหมายด้วยเมาส์หรือปุ่มลูกศร", "สลับตัวเลือกรถบรรทุกมิติ", "ขนาดรถบรรทุก", "สลับตัวเลือกชนิดการโหลด", "โหมดการเดินทาง", "การเลือกพื้นที่", "ระยะทาง", "หน่วยความยาว", "ความยาว", "ความสูง", "ความกว้าง", "น้ำหนัก Axle", "รถยนต์", "รถบรรทุก", "คนเดินเท้า", "รถจักรยาน", "ลากเครื่องหมายไปยังสถานที่กำเนิดเลือก", "เวลา", "ใช้เวลาเดินทาง (นาที)", "หน่วยระยะทาง", "เมตร", "ไมล์", "กิโลเมตร", "หลา", "ฟุต", "หน่วยน้ำหนัก", "กิโลกรัม", "ตันยาว", "เมตริกตัน", "ปอนด์", "ตันสั้น", "ประเภทการโหลด", "หลีกเลี่ยงการ", "ค้นหา", "ยกเลิก", "ข้ามพรมแดน", "Carpools", "เรือข้ามฟาก", "มอเตอร์เวย์", "ถนนโทร", "ถนนลูกรัง", "ที่เป็นอันตรายลงไปในน้ำ", "เบ็ดเตล็ด", "ออกซิไดเซอร์", "สารพิษ", "กัมมันตรังสี", "บีบอัดก๊าซ", "กัดกร่อน", "วัตถุระเบิด", "ของเหลวไวไฟ", "ของแข็งไวไฟ", "เลือกวงกลม", "เลือกสี่เหลี่ยมผืนผ้า", "เลือกรูปหลายเหลี่ยม", "เลือกเวลาในการเดินทาง", "แสดงพื้นที่", "การจราจร", "รวมถึงการจราจรในการคำนวณ", "ออกจากที่", "ณ วันที่ฝาก", "ทิ้งไว้ตลอดเวลา", "โหมดการเลือก", "เลือกโหมด", "ตัวเลือกการหลีกเลี่ยงการสลับ", "เกิดข้อผิดพลาดขอรูปหลายเหลี่ยมช่วงเส้นทาง"], tr: ["Veri seçim kontrolü", "Rota kontrolünü değişir. Fare ile işaretleyici sürükleyerek kökenli konumu seçin veya ok tuşlarını kullanın.", "Geçiş kamyon boyut seçenekleri", "Araç boyutları", "Geçiş yük tipi seçenekleri", "Seyahat modu", "Seçim bölgesi", "Mesafe", "Uzunluk birimleri", "uzunluk", "Yükseklik", "Genişlik", "Dingil ağırlığı", "Araba", "Kamyon", "Yaya", "Bisiklet", "seçme kökenli konuma sürükleyin işaretleyici", "Zaman", "Seyahat süresi (dakika)", "Uzaklık birimleri", "Metre", "Miles", "Kilometre", "Yards", "Ayaklar", "Ağırlık birimleri", "Kilogram", "Uzun ton", "Ton", "Pound", "Kısa ton", "Yük tipi", "Önlemek", "Arama", "İptal etmek", "Sınır geçişleri", "Ortak araba", "Feribot", "Otoyolları", "Paralı yollar", "Asfaltsız yollar", "Suya zararlı", "Çeşitli", "Oksidanlar", "Zehirler", "Radyoaktif", "Sıkıştırılmış gaz", "Korozivler", "Patlayıcılar", "Yanıcı sıvılar", "Yanıcı katılar", "Çember seçim", "Dikdörtgen seçimi", "Poligon seçimi", "Seyahat süresi seçimi", "Göster alanı", "Trafik", "Hesaplamada trafiği dahil", "en bırakın", "tarihte bırakın", "anda bırakın", "Seçim modları", "Mod seç", "Geçiş önlemek seçenekleri", "Rota aralığı çokgen talep hata."], uk: ["Контроль вибору даних", "Маршрут діапазон регулювання. Виберіть місце розташування походження шляхом перетягування маркера за допомогою миші або клавіші зі стрілками.", "Перемикання варіантів вимірювання вантажівки", "розміри вантажних автомобілів", "Параметри типу навантаження Перемикання", "Режим подорожі", "Область вибору", "Відстань", "Довжина блоків", "довжина", "висота", "ширина", "вага міст", "Автомобіль", "Вантажівка", "Пішохід", "Велосипед", "Перетягніть маркер вибору місця походження", "Час", "Час в дорозі (хв)", "Ед.ізмер.расст", "Метри", "Миль", "Кілометрів", "Ярди", "Ноги", "Вага одиниці", "Кілограми", "Довга тонна", "Метрична тонна", "Фунти", "Коротка тонна", "Тип навантаження", "Уникайте", "Пошук", "Скасувати", "Прикордонні переходи", "Спільне використання автомобіля", "Пороми", "Магістралі", "Платні дороги", "Грунтові дороги", "Шкідливий для води", "Різне", "Окислювачі", "Отрути", "Радіоактивне", "Стиснутий газ", "Їдкі", "Вибухові речовини", "Горючі рідини", "Легкозаймисті тверді речовини", "Вибір коло", "Вибір прямокутник", "Вибір polygon", "Вибір часу для подорожей", "Показати область", "трафік", "Увімкніть трафік в розрахунку", "Залиште", "Залиште на день", "Залиште на час", "режими вибору", "Вибір режиму роботи", "Варіанти остерігайтеся Переключити", "Помилка запиту діапазону маршруту багатокутник."], vi: ["kiểm soát lựa chọn dữ liệu", "Route dao động kiểm soát. Chọn vị trí gốc bằng cách kéo điểm đánh dấu bằng chuột hoặc phím mũi tên.", "Chuyển đổi tùy chọn chiều xe tải", "kích thước xe tải", "Chuyển đổi kiểu tùy chọn tải", "Chế độ du lịch", "Khu vực lựa chọn", "Khoảng cách", "Đơn vị chiều dài", "Chiều dài", "Chiều cao", "Chiều rộng", "Trọng lượng trục", "Xe hơi", "Xe tải", "Người đi bộ", "Xe đạp", "Kéo điểm đánh dấu để chọn vị trí gốc", "Thời gian", "Thời gian đi lại (phút)", "Đơn vị khoảng cách", "Mét", "Miles", "Km", "Yards", "Đôi chân", "Đơn vị trọng lượng", "Kg", "Dài lâu", "Tấn", "Bảng", "Tấn ngắn", "Loại tải", "Tránh", "Tìm kiếm", "Hủy bỏ", "Đường biên giới", "Carpool", "Phà", "Đường cao tốc", "Đường toll", "Con đường không trải nhựa", "Có hại cho nước", "Điều khoản khác", "Oxi hóa", "Độc", "Phóng xạ", "Khí nén", "Các chất ăn mòn", "Chất nổ", "Chất lỏng dễ cháy", "Chất rắn dễ cháy", "Vòng tròn lựa chọn", "Lựa chọn hình chữ nhật", "Lựa chọn polygon", "Lựa chọn thời gian đi lại", "Hiện khu vực", "Giao thông", "Bao gồm giao thông trong tính toán", "Để lại tại", "Để lại vào ngày", "Rời khỏi lúc", "chế độ lựa chọn", "Chọn chế độ", "lựa chọn tránh Toggle", "Lỗi yêu cầu phạm vi tuyến đường đa giác."] }, Wt = (Xt.getResource = function (t) { t ? 0 < (t = t.toLowerCase()).indexOf("-") && (t = t.substring(0, t.indexOf("-"))) : t = "en", this._resxCache || (this._resxCache = {}); var e = Object.keys(this._resxCache), r = Object.keys(Yt); if (-1 === e.indexOf(t) && (-1 === r.indexOf(t) && (t = "en"), -1 === e.indexOf(t))) { var n = {}; Jt.forEach(function (e, r) { n[e] = Yt[t][r] }), this._resxCache[t] = n } return this._resxCache[t] }, Xt); function Xt() { } var $t = (Zt.prototype.dispose = function () { var r = this; this._container && (this._container = null), this.updateMap(null), Object.keys(this).forEach(function (e) { r[e] = null }) }, Zt.prototype.updateMap = function (e) { this._map && this._style === p.ControlStyle.auto && this._map.events.remove("styledata", this._onStyleChange), (this._map = e) && this._style === p.ControlStyle.auto && e.events.add("styledata", this._onStyleChange) }, Zt.prototype.setStyle = function (e) { var r = this; e !== r._style && (r._container.classList.remove(e), r._style === p.ControlStyle.auto && r._map.events.remove("styledata", r._onStyleChange), e.toLowerCase() === p.ControlStyle.auto ? (r._onStyleChange(), r._map.events.add("styledata", r._onStyleChange)) : r._container.classList.add(e), r._style = e) }, Zt.prototype._setTheme = function (e) { this._theme !== e && (this._container.classList.remove(this._theme), this._container.classList.add(e), this._theme = e) }, Zt); function Zt(e, r, t) { var o = this; this._onStyleChange = function () { if (o._map.getStyle().style.toLowerCase().startsWith("blank")) o._observer || (o._onBackgroundChange(), o._observer = new MutationObserver(o._onBackgroundChange), o._observer.observe(o._map.getMapContainer(), { attributes: !0, attributeFilter: ["style"] })); else { o._observer && (o._observer.disconnect(), delete o._observer); var e = "light"; -1 < ["satellite", "satellite_road_labels", "grayscale_dark", "night"].indexOf(o._map.getStyle().style) && (e = "dark"), o._setTheme(e) } }, this._onBackgroundChange = function () { try { var e = o._map.getMapContainer().style.backgroundColor; if ("" === e) o._setTheme("light"); else { var r = qt.createElm("canvas", { style: { width: "1px", height: "1px", position: "absolute", visibility: "hidden" } }).getContext("2d"); r.beginPath(), r.rect(0, 0, 1, 1), r.fillStyle = e, r.fill(); var t = r.getImageData(0, 0, 1, 1).data.slice(0, 4); t[3] = t[3] / 255; var n = 127 < Math.sqrt(.299 * t[0] * t[0] + .587 * t[1] * t[1] + .114 * t[2] * t[2]) ? "light" : "dark"; o._setTheme(n) } } catch (e) { o._setTheme("light") } }, this._container = e, this._map = r, this.setStyle(t) } var Qt = (en.prototype.dispose = function () { this._events; var r = Object.keys(this._events); r.forEach(function (e) { r[e].elm.removeEventListener(e, r[e].callack) }), this._events = null, this._target = null }, en.prototype.bind = function (i, a, s, u) { var l = this; return i && (l.addEvent(i, "onchange", function () { var e = i.value, r = i; if ("LABEL" === i.tagName && (r = i.firstChild), "INPUT" === r.tagName) { var t = r; switch (t.type) { case "number": e = parseFloat(e); break; case "checkbox": if (s) { var n = l._target[a], o = (n = n || []).indexOf(t.value); t.checked && -1 === o ? n.push(t.value) : !t.checked && -1 < o && (n = n.splice(o, 1)), e = n } else e = t.checked } } l._target[a] = e, u && u(e) }), i.onchange(new Event("onchange"))), l }, en.prototype.addEvent = function (e, r, t) { if (e && r && t) { var n = this._events; n[r] || (n[r] = []), n[r].push({ elm: e, callack: t }), e.addEventListener(r, t), e[r] = t } }, en); function en(e) { this._events = {}, this._target = e } var rn, tn, nn = (e(on, rn = p.internal.EventEmitter), on.prototype.dispose = function () { var r = this; r._map && r._map.controls.remove(r), r._binding && (r._binding.dispose(), r._binding = null), r._styler && r._styler.dispose(), Object.keys(r).forEach(function (e) { r[e] = null }) }, on.prototype.setMarkerOptions = function (e) { Object.assign(this._options.markerOptions, e), this._marker.setOptions(e) }, on.prototype.setVisible = function (e) { var r = this; if (r._marker && r._map) { var t = r._map.getCamera(), n = t.center; r._settings.origin && p.data.BoundingBox.containsPosition(t.bounds, r._settings.origin) && (n = r._settings.origin), r._settings.origin = n, r._marker.setOptions({ position: n, visible: e }), e && r._options.calculateOnMarkerMove && r._onSearch() } if (r._container) { var o = e ? "" : "none"; r._optionSection.style.display = "none", r._searchBtn.style.display = "none", r._container.style.display = o, e && (r._hideOptionsTimeout = setTimeout(function () { r._optionSection.style.display = "", r._searchBtn.style.display = "", r._hideOptionsTimeout = null }, r._showOptionsDelay)) } r._options.isVisible !== e && e && r._container && r._container.focus(), r._options.isVisible = e }, on.prototype.getOptions = function () { return Object.assign({}, this._options) }, on.prototype.onAdd = function (e, r) { if (r && r.position && "non-fixed" !== r.position) return e.controls.remove(this), void e.controls.add(this, { position: "non-fixed" }); var t = this; t._map = e; var n = t._marker; n.setOptions({ visible: t._options.isVisible }), e.markers.add(n); var o = e.events; o.add("dragstart", n, t._onMarkerDargStart), o.add("dragend", n, t._onMarkerDragged); var i = Wt.getResource(e.getStyle().language); return t._resx = i, t._createContainer(i), t._styler ? t._styler.updateMap(e) : t._styler = new $t(t._container, e, t._options.style || "light"), t._container }, on.prototype.onRemove = function () { var e = this, r = e._container; r && (r.removeEventListener("keydown", this._onContainerKeyDown), r.remove(), e._container = null), e._binding && (e._binding.dispose(), e._binding = null), e._styler.updateMap(null); var t = e._map, n = t.events, o = e._marker; n.remove("resize", e._mapResized), n.remove("dragstart", o, e._onMarkerDargStart), n.remove("dragend", o, e._onMarkerDragged), t.markers.remove(o), e._map = null }, on.prototype._createOptionRow = function (e, r, t) { var n = on._css; return qt.createElm("div", { class: [n.row], children: [qt.createElm("div", { class: [n.col1, t ? "indent" : void 0], innerHTML: e }), qt.createElm("div", { class: [n.col2], children: Array.isArray(r) ? r : [r] })] }) }, on.prototype._createToggleBtn = function (e, r, t) { var n = on._css, o = qt.createElm("button", { attr: { type: "button", "aria-expanded": "false", "aria-label": r }, class: [n.expndBtn], innerHTML: e + ' <span class="' + n.toggleIcon + '"></span>' }); return t.forEach(function (e) { e.style.display = "none" }), o.onclick = function () { var e = o.getAttribute("aria-expanded"), r = ""; "true" === e ? (e = "false", r = "none", o.getElementsByClassName(n.toggleIcon)[0].classList.remove(n.expandedToggleIcon)) : (e = "true", o.getElementsByClassName(n.toggleIcon)[0].classList.add(n.expandedToggleIcon)), o.setAttribute("aria-expanded", e), t.forEach(function (e) { e.style.display = r }) }, o }, on.prototype._createCheckboxGroup = function (e, r, t, n) { var o, i, a, s = on._css, u = r.length, l = Math.ceil(u / 2), c = [], d = []; for (i = 0; i < u; i++)o = qt.createElm("input", { attr: { type: "checkbox", value: r[i] }, propName: r[i] }, t), a = qt.createElm("label", { innerHTML: t[r[i]], children: [o] }), this._binding.bind(a, e, !0, n), i < l ? (c.push(a), i < l - 1 && c.push(document.createElement("br"))) : (d.push(a), i < u - 1 && d.push(document.createElement("br"))); var g = qt.createElm("div", { class: [s.col1], style: { display: "none" }, children: c }), f = qt.createElm("div", { class: [s.col2], style: { display: "none" }, children: d }), m = qt.createElm("div", { class: [s.row], children: [g, f] }); return [this._createToggleBtn(t[e], t[e + "Toggle"], [g, f]), m] }, on.prototype._getDateTimePickerDisplay = function () { return qt.isDateTimeInputSupported() && "time" === this._settings.selectionArea && this._settings.traffic && ("car" === this._settings.travelMode || "truck" === this._settings.travelMode) ? "" : "none" }, on._css = { root: "atlas-route-range-", container: "atlas-route-range-container", row: "atlas-route-range-row", col1: "atlas-route-range-col1", col2: "atlas-route-range-col2", instructions: "atlas-route-range-instructions", options: "atlas-route-range-options", searchBtn: "atlas-route-range-search-btn", cancelBtn: "atlas-route-range-cancel-btn", expndBtn: "atlas-route-range-expand-btn", toggleIcon: "atlas-route-range-toggle-icon", expandedToggleIcon: "atlas-route-range-toggle-icon-expanded" }, on); function on(e) { var G = rn.call(this) || this; G._options = { markerOptions: { color: "#F2C811", secondaryColor: "#011C2C", htmlContent: '<svg xmlns="http://www.w3.org/2000/svg" style="cursor:move" width="28px" height="39px" viewBox="-1 -1 27 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:2"/><g style="transform:scale(0.2);transform-origin: 13% 10%;"><path d="m50 38h-4v14c0 0 0 1 0 1l9 9 2-2-9-9v-13z" fill="{secondaryColor}" stroke="{secondaryColor}" stroke-width="2px"/><path d="m48 81c-15 0-28-12-28-28s12-28 28-28 28 12 28 28-12 28-28 28zm23-52 3-3c1-1 1-3-0-4-1-1-3-1-4-0l-3 3c-4-3-10-5-16-5v-4h9v-6h-24v6h9v4c-15 1-28 13-30 29s7 31 22 36 31-0 40-14 6-31-5-42z" fill="{secondaryColor}" stroke="{secondaryColor}" stroke-width="2px"/></g></svg>' }, style: p.ControlStyle.light, isVisible: !0, position: "left", collapsible: !1, calculateOnMarkerMove: !0 }, G._markerMoveSearchDelay = 600, G._arrowKeyOffset = 5, G._showOptionsDelay = 0, G._settings = {}, G._createContainer = function (e) { var n = G, r = on._css, t = qt.createElm, o = new Qt(n._settings); n._binding = o; var i = qt.createElm("div", { class: ["azure-maps-control-container", on._css.container], style: { display: n._options.isVisible ? "" : "none" }, attr: { "aria-label": e.routeRangeControl, tabindex: "-1" } }); i.addEventListener("keydown", G._onContainerKeyDown), n._container = i; var a = t("input", { attr: { type: "number", value: "15", min: "1", max: "1440" }, propName: "travelTime" }, e, o), s = n._createOptionRow(e.travelTime, a), u = t("input", { attr: { type: "number", value: "5", min: "1", max: "1000" }, propName: "distance" }, e, o), l = t("select", { selectVals: ["meters", "miles", "kilometers", "yards"], selected: "kilometers", propName: "distanceUnits" }, e, o), c = n._createOptionRow(e.distance, [u, l]), d = t("input", { attr: { type: "checkbox", checked: "checked" }, propName: "showArea" }, e, o), g = t("input", { attr: { type: "date" }, style: { marginBottom: "3px" }, propName: "leaveAtDate" }, e, o), f = t("input", { attr: { type: "time", step: "300" }, propName: "leaveAtTime" }, e, o), m = n._createOptionRow(e.leaveAt, [g, f]); if (m.style.display = "none", qt.isDateTimeInputSupported()) { var h = new Date, p = h.getHours(), y = h.getMinutes(); 60 === (y = 5 * Math.ceil(y / 5)) && (p++, y = 0), h = new Date(h.toDateString()), p = (h = new Date(h.setHours(p, y))).getHours(), n._settings.leaveAtDate = h.toISOString().split("T")[0], g.value = n._settings.leaveAtDate, g.setAttribute("min", n._settings.leaveAtDate); var v = (p < 10 ? "0" : "") + qt.USNumberFormat(p), b = (y < 10 ? "0" : "") + qt.USNumberFormat(y); n._settings.leaveAtTime = v + ":" + b, f.value = n._settings.leaveAtTime } var w = t("input", { attr: { type: "number", min: "0" }, propName: "length" }, e, o), k = t("select", { selectVals: ["feet", "meters", "yards"], selected: "meters", propName: "lengthUnits" }, e, o), P = n._createOptionRow(e.length, [w, k], !0), E = t("input", { attr: { type: "number", min: "0" }, propName: "height" }, e, o), S = n._createOptionRow(e.height, E, !0), T = t("input", { attr: { type: "number", min: "0" }, propName: "width" }, e, o), M = n._createOptionRow(e.width, T, !0), A = t("input", { attr: { type: "number", min: "0" }, propName: "axleWeight" }, e, o), R = t("select", { selectVals: ["kilograms", "longTon", "metricTon", "pounds", "shortTon"], selected: "kilograms", propName: "weightUnits" }, e, o), C = n._createOptionRow(e.axleWeight, [A, R], !0), x = n._createToggleBtn(e.truckDimensions, e.truckDimensionsToggle, [P, S, M, C]), F = n._createCheckboxGroup("loadType", ["USHazmatClass2", "USHazmatClass8", "USHazmatClass1", "USHazmatClass3", "USHazmatClass4", "otherHazmatHarmfulToWater", "USHazmatClass9", "USHazmatClass5", "USHazmatClass6", "USHazmatClass7"], e, function (e) { var r = e.indexOf("USHazmatClass1"), t = e.indexOf("otherHazmatExplosive"); 0 < r ? -1 === t && e.push("otherHazmatExplosive") : 0 < t && (e = e.splice(t, 1)); var n = e.indexOf("USHazmatClass9"), o = e.indexOf("otherHazmatGeneral"); 0 < n ? -1 === o && e.push("otherHazmatGeneral") : 0 < o && (e = e.splice(o, 1)) }), O = [x, F[0]], L = n._createCheckboxGroup("avoid", ["borderCrossings", "carpools", "ferries", "motorways", "tollRoads", "unpavedRoads"], e), _ = t("input", { attr: { type: "checkbox" }, propName: "traffic", bindingChanged: function (e) { m.style.display = n._getDateTimePickerDisplay() } }, e, o), j = n._createOptionRow(e.traffic, _), I = t("select", { selectVals: ["distance", "time"], selected: "time", propName: "selectionArea", bindingChanged: function (e) { var r = "time" === e; s.style.display = r ? "" : "none", c.style.display = r ? "none" : "", j.style.display = !r || "car" !== n._settings.travelMode && "truck" !== n._settings.travelMode ? "none" : "", m.style.display = n._getDateTimePickerDisplay() } }, e, o), z = t("select", { selectVals: ["car", "bicycle", "pedestrian", "truck"], selected: "car", propName: "travelMode", bindingChanged: function (e) { var r = !0, t = !1; switch (e) { case "pedestrian": case "bicycle": r = !1; break; case "truck": t = !0 }L.forEach(function (e) { e.style.display = r ? "" : "none" }), O.forEach(function (e) { e.style.display = t ? "" : "none", t || "true" !== e.getAttribute("aria-expanded") || e.click() }), j.style.display = r && "time" === n._settings.selectionArea ? "" : "none", m.style.display = n._getDateTimePickerDisplay() } }, e, o), D = t("button", { class: [r.searchBtn], propName: "search", innerHTML: e.search }, e); D.onclick = n._onSearch, n._searchBtn = D; var N = t("button", { class: [r.cancelBtn], propName: "cancel", innerHTML: e.cancel }, e); n._options.collapsible || (N.style.display = "none"), N.onclick = n._onCancel; var B = qt.createElm("div", { class: [r.row], style: { display: "block" }, children: [qt.createElm("div", { style: { "text-align": "center" }, children: [D, N] })] }); n._optionSection = t("div", { class: [r.options], children: [n._createOptionRow(e.travelMode, z), n._createOptionRow(e.selectionArea, I), s, c, n._createOptionRow(e.showArea, d), j, m, x, P, S, M, C, F[0], F[1], L[0], L[1]] }), qt.appendChildren(i, [t("div", { class: [r.instructions], innerHTML: e.selectOrigin }, e), n._optionSection, B]), n._map.events.add("resize", n._mapResized), n._mapResized(), n._options.isVisible && n.setVisible(n._options.isVisible) }, G._onSearch = function () { var n = G, e = p.math.convertDistance, r = Math.round, t = n._settings, o = qt.USNumberFormat, i = []; if (i.push("query=" + o(t.origin[1]) + "," + o(t.origin[0])), i.push("travelMode=" + t.travelMode), "time" === t.selectionArea) { if (i.push("timeBudgetInSec=" + o(r(60 * t.travelTime))), t.traffic && (i.push("traffic=true"), t.leaveAtDate && t.leaveAtTime)) { var a = t.leaveAtTime; 1 === a.match(/:/g).length && (a += ":00"), i.push("departAt=" + t.leaveAtDate + "T" + a) } } else i.push("distanceBudgetInMeters=" + o(r(e(t.distance, t.distanceUnits, "meters")))); "car" !== t.travelMode && "truck" !== t.travelMode || t.avoid && t.avoid.forEach(function (e) { i.push("avoid=" + e) }), "truck" === t.travelMode && (isNaN(t.length) || i.push("vehcileLength=" + o(r(e(t.length, t.lengthUnits, "meters")))), isNaN(t.width) || i.push("vehicleWidth=" + o(r(e(t.width, t.lengthUnits, "meters")))), isNaN(t.height) || i.push("vehicleHeight=" + o(r(e(t.height, t.lengthUnits, "meters")))), isNaN(t.height) || i.push("vehicleAxleWeight=" + o(r(Kt.convertWeight(t.axleWeight, t.weightUnits, "kilograms")))), t.loadType && t.loadType.forEach(function (e) { i.push("vehicleLoadType=" + e) })); var s = "https://" + n._map.getServiceOptions().domain + "/route/range/json?api-version=1.0&" + i.join("&"), u = n._map.authentication.signRequest({ url: s }); fetch(u.url, { method: "GET", mode: "cors", headers: new Headers(u.headers) }).then(function (e) { return e.json() }, function (e) { return n._invokeEvent("error", n._resx.routeRangeError) }).then(function (e) { if (e.reachableRange) { var r = e.reachableRange.boundary.map(function (e) { return [e.longitude, e.latitude] }), t = new p.data.Polygon([r]); n._invokeEvent("rangecalculated", t), n._settings.showArea && n._invokeEvent("showrange", t) } else n._invokeEvent("error", n._resx.routeRangeError) }, function (e) { return n._invokeEvent("error", n._resx.routeRangeError) }), n._options.collapsible && n.setVisible(!1) }, G._onCancel = function () { G.setVisible(!1) }, G._onMarkerDragged = function () { var e = G; e._settings.origin = e._marker.getOptions().position, e._optionSection.style.display = "", e._searchBtn.style.display = "", e._hideOptionsTimeout = null, e._options.calculateOnMarkerMove && e._onSearch() }, G._onMarkerDargStart = function () { G._hideOptionsTimeout && (clearTimeout(G._hideOptionsTimeout), G._hideOptionsTimeout = null) }, G._onContainerKeyDown = function (e) { if (36 < e.keyCode && e.keyCode < 41 && e.target.classList.contains("azure-maps-control-container")) { var r = G, t = r._map.getCamera().zoom, n = p.math.mercatorPositionsToPixels([r._marker.getOptions().position], t)[0], o = r._arrowKeyOffset; 37 === e.keyCode ? n[0] -= o : 38 === e.keyCode ? n[1] -= o : 39 === e.keyCode ? n[0] += o : 40 === e.keyCode && (n[1] += o); var i = p.math.mercatorPixelsToPositions([n], t)[0]; r._marker.setOptions({ position: i }), r._settings.origin = i, r._options.calculateOnMarkerMove && (r._markerKeyMoveTimeout && clearTimeout(r._markerKeyMoveTimeout), r._markerKeyMoveTimeout = setTimeout(function () { r._onSearch() }, r._markerMoveSearchDelay)), e.preventDefault(), e.stopPropagation() } }, G._mapResized = function () { var e = G, r = e._map.getMapContainer().getBoundingClientRect(), t = "", n = 0, o = e._options.position; if (r.width < 750 || "center" === o && r.height < 600) t = "-min", n = 5e3; else if ("center" !== o) { var i = Array.from(e._map.controls.controlContainer.children), a = 0; i.forEach(function (e) { -1 < e.classList.toString().indexOf(o) && (a += e.children.length) }), 0 === a && (t = "-min") } e._container.classList.remove("left", "right", "center", "left-min", "right-min", "center-min"), e._container.classList.add(o + t), e._showOptionsDelay = n }; var r = G; return e.markerOptions && Object.assign(e.markerOptions, r._options.markerOptions), r._options = Object.assign(r._options, e || {}), r._marker = new p.HtmlMarker(Object.assign(r._options.markerOptions, { draggable: !0 })), G } (tn = d.SelectionControlMode || (d.SelectionControlMode = {})).circle = "circle", tn.rectangle = "rectangle", tn.polygon = "polygon", tn.routeRange = "routeRange"; var an, sn = (e(un, an = p.internal.EventEmitter), un.prototype.clear = function () { this._drawingManager.getSource().clear(), this._rangeDataSource.clear() }, un.prototype.dispose = function () { var r = this; r._map && r._map.controls.remove(r), r._styler && r._styler.dispose(), Object.keys(r).forEach(function (e) { r[e] = null }) }, un.prototype.getDrawingManager = function () { return this._drawingManager }, un.prototype.getOptions = function () { return Object.assign({}, this._options) }, un.prototype.setSource = function (e) { this._options.source = e }, un.prototype.onAdd = function (e, r) { var t = this; t._position = r && r.position ? r.position : "non-fixed", t._map = e; var n = t._options, o = new u.drawing.DrawingManager(e); t._drawingManager = o, e.events.add("drawingcomplete", o, t._searchArea), e.events.add("drawingchanged", o, t._copyDrawnShape); var i = o.getLayers(); i.polygonLayer.setOptions({ fillColor: n.fillColor, fillOpacity: n.fillOpacity }); var a = { strokeColor: n.strokeColor, strokeWidth: n.strokeWidth }; i.polygonOutlineLayer.setOptions(a), i.lineLayer.setOptions(a), e.sources.add(t._rangeDataSource), t._rangeLayers = [new p.layer.PolygonLayer(t._rangeDataSource, null, i.polygonLayer.getOptions()), new p.layer.LineLayer(t._rangeDataSource, null, i.lineLayer.getOptions())], t._map.layers.add(t._rangeLayers, "transit"); var s = Wt.getResource(e.getStyle().language); return t._createContainer(s), t._styler ? t._styler.updateMap(e) : t._styler = new $t(t._container, e, n.style || "light"), t._container }, un.prototype.onRemove = function () { var e = this, r = e._map; if (e.clear(), e._container && (e._container.remove(), e._container = null), r) { var t = r.events, n = e._rangeControl; n && (t.remove("showrange", n, e._displayRangePolygon), t.remove("rangecalculated", n, e._searchArea), r.controls.remove(n), e._rangeControl = null), t.remove("resize", e._mapResized), r.sources.remove(e._rangeDataSource), t.remove("drawingchanged", e._drawingManager, e._copyDrawnShape), e._rangeLayers && r.layers.remove(e._rangeLayers) } e._styler.updateMap(null), e._drawingManager && (e._drawingManager.dispose(), e._drawingManager = null), e._map = null }, un.prototype._createContainer = function (t) { var n = this, e = n._options, o = un._css, r = qt.createElm("div", { class: ["azure-maps-control-container"], propName: "selectionControl" }, t); n._container = r; var i = qt.createElm("div", { class: [o.hidden], propName: "selectionModes" }, t), a = Object.keys(d.SelectionControlMode); Array.isArray(e.selectionModes) && (a = e.selectionModes), a.forEach(function (e) { var r = n._buildSelectModeBtn(e, o.button, t); i.appendChild(r), "routeRange" === e && (n._routeRangeBtn = r) }), r.addEventListener("mouseover", function () { n._hasMouse = !0, r.classList.add(o.inUse), i.classList.remove(o.hidden) }), r.addEventListener("focusin", function () { n._hasFocus = !0, r.classList.add(o.inUse), i.classList.remove(o.hidden) }), r.addEventListener("mouseleave", function () { n._hasMouse = !1, n._hasFocus || (r.classList.remove(o.inUse), i.classList.add(o.hidden)) }), r.addEventListener("focusout", function (e) { e.relatedTarget instanceof Node && r.contains(e.relatedTarget) || (n._hasFocus = !1, n._hasMouse || (r.classList.remove(o.inUse), i.classList.add(o.hidden))) }); var s = qt.createElm("button", { class: [o.button, "pointer-selection"], propName: "selectMode", attr: { type: "button" } }, t); s.addEventListener("click", function () { n.clear() }), !e || "top-right" !== n._position && "bottom-right" !== n._position ? (r.appendChild(s), r.appendChild(i)) : (r.appendChild(i), r.appendChild(s)); var u = { isVisible: !1, markerOptions: { color: e.fillColor }, style: e.style || p.ControlStyle.light, collapsible: !0, calculateOnMarkerMove: !1 }; e.routeRangeOptions && (e.routeRangeOptions.markerOptions && (e.routeRangeOptions.markerOptions = Object.assign(u.markerOptions, e.routeRangeOptions.markerOptions)), Object.assign(u, e.routeRangeOptions)); var l = new nn(u), c = n._map; c.controls.add(l), n._rangeControl = l, c.events.add("resize", n._mapResized), n._mapResized(), c.events.add("rangecalculated", l, n._searchArea), c.events.add("showrange", l, n._displayRangePolygon) }, un.prototype._buildSelectModeBtn = function (e, r, t) { var n = qt.createElm("button", { attr: { type: "button" }, propName: e + "Selection", class: [r, e + "-selection"] }, t), o = this; return n.onclick = function () { o.clear(), "routeRange" === e ? o._rangeControl.setVisible(!0) : o._drawingManager.setOptions({ mode: "draw-" + e }) }, n }, un._css = { button: "azure-maps-control-button", inUse: "in-use", hidden: "hidden-accessible-element" }, un); function un(e) { var n = an.call(this) || this; return n._options = { style: p.ControlStyle.light, selectionModes: "all", fillColor: "#F2C811", fillOpacity: .5, strokeColor: "#F2C811", strokeWidth: 1, persistSearchArea: !1, routeRangeMinMapSize: [325, 200], routeRangeOptions: {}, shapeSelectionMode: "any" }, n._hasMouse = !1, n._hasFocus = !1, n._copyDrawnShape = function (e) { n._rangeDataSource.setShapes([new p.Shape(new p.data.Polygon(e.getCoordinates()))]) }, n._displayRangePolygon = function (e) { n._rangeDataSource.setShapes([e]) }, n._searchArea = function (e) { var r = n; r.clear(); var t = r._options.source; t && e && r._invokeEvent("dataselected", Kt.shapesIntersectPolygon(t.getShapes(), e)), r._drawingManager.setOptions({ mode: "idle" }) }, n._mapResized = function () { var e = n, r = e._options.routeRangeMinMapSize, t = e._map.getMapContainer().getBoundingClientRect(); e._routeRangeBtn.style.display = t.width >= r[0] && t.height >= r[1] ? "" : "none" }, n._options = Object.assign(n._options, e || {}), n._rangeDataSource = new p.source.DataSource(null, { buffer: 512 }), n } var ln = Object.freeze({ __proto__: null, SelectionControl: sn, RouteRangeControl: nn }), cn = r.merge("atlas.control", ln), dn = r.merge("atlas.math", Kt); d.control = cn, d.math = dn }(this.atlas = this.atlas || {}, atlas, atlas);