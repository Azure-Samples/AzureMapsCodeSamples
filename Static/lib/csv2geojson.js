!function (e) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else { ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).csv2geojson = e() } }(function () { return function () { return function e(r, t, n) { function o(a, u) { if (!t[a]) { if (!r[a]) { var s = "function" == typeof require && require; if (!u && s) return s(a, !0); if (i) return i(a, !0); var l = new Error("Cannot find module '" + a + "'"); throw l.code = "MODULE_NOT_FOUND", l } var f = t[a] = { exports: {} }; r[a][0].call(f.exports, function (e) { return o(r[a][1][e] || e) }, f, f.exports, e, r, t, n) } return t[a].exports } for (var i = "function" == typeof require && require, a = 0; a < n.length; a++)o(n[a]); return o } }()({ 1: [function (e, r, t) { "use strict"; var n = e("d3-dsv"), o = e("@mapbox/sexagesimal"), i = /(Lat)(itude)?/gi, a = /(L)(on|ng)(gitude)?/i; function u(e, r) { var t, n, o; for (var i in e) (n = i.match(r)) && (!t || n[0].length / i.length > o) && (o = n[0].length / i.length, t = i); return t } function s(e) { return u(e, i) } function l(e) { return u(e, a) } function f(e) { return "object" == typeof e ? Object.keys(e).length : 0 } function c(e) { var r = []; return [",", ";", "\t", "|"].forEach(function (t) { var o = n.dsvFormat(t).parse(e); if (o.length >= 1) { for (var i = f(o[0]), a = 0; a < o.length; a++)if (f(o[a]) !== i) return; r.push({ delimiter: t, arity: Object.keys(o[0]).length }) } }), r.length ? r.sort(function (e, r) { return r.arity - e.arity })[0].delimiter : null } r.exports = { isLon: function (e) { return !!e.match(a) }, isLat: function (e) { return !!e.match(i) }, guessLatHeader: s, guessLonHeader: l, csv: n.csvParse, tsv: n.tsvParse, dsv: n, auto: function (e) { var r, t = c(e); return t ? (delete (r = n.dsvFormat(t).parse(e)).columns, r) : null }, csv2geojson: function (e, r, t) { t || (t = r, r = {}), r.delimiter = r.delimiter || ","; var i = r.latfield || "", a = r.lonfield || "", u = r.crs || "", f = [], p = { type: "FeatureCollection", features: f }; if ("" !== u && (p.crs = { type: "name", properties: { name: u } }), "auto" !== r.delimiter || "string" != typeof e || (r.delimiter = c(e), r.delimiter)) { var d = r.numericFields ? r.numericFields.split(",") : null, v = "string" == typeof e ? n.dsvFormat(r.delimiter).parse(e, function (e) { if (d) for (var r in e) d.includes(r) && (e[r] = +e[r]); return e }) : e; if (v.length) { var m, g = []; if (i || (i = s(v[0])), a || (a = l(v[0])), i && a) { for (m = 0; m < v.length; m++)if (void 0 !== v[m][a] && void 0 !== v[m][i]) { var h, y, F, w = v[m][a], x = v[m][i]; (F = o(w, "EW")) && (w = F), (F = o(x, "NS")) && (x = F), h = parseFloat(w), y = parseFloat(x), isNaN(h) || isNaN(y) ? g.push({ message: "A row contained an invalid value for latitude or longitude", row: v[m], index: m }) : (r.includeLatLon || (delete v[m][a], delete v[m][i]), f.push({ type: "Feature", properties: v[m], geometry: { type: "Point", coordinates: [parseFloat(h), parseFloat(y)] } })) } t(g.length ? g : null, p) } else { for (m = 0; m < v.length; m++)f.push({ type: "Feature", properties: v[m], geometry: null }); t(g.length ? g : null, p) } } else t(null, p) } else t({ type: "Error", message: "Could not autodetect delimiter" }) }, toLine: function (e) { for (var r = e.features, t = { type: "Feature", geometry: { type: "LineString", coordinates: [] } }, n = 0; n < r.length; n++)t.geometry.coordinates.push(r[n].geometry.coordinates); return t.properties = r.reduce(function (e, r) { for (var t in r.properties) e[t] || (e[t] = []), e[t].push(r.properties[t]); return e }, {}), { type: "FeatureCollection", features: [t] } }, toPolygon: function (e) { for (var r = e.features, t = { type: "Feature", geometry: { type: "Polygon", coordinates: [[]] } }, n = 0; n < r.length; n++)t.geometry.coordinates[0].push(r[n].geometry.coordinates); return t.properties = r.reduce(function (e, r) { for (var t in r.properties) e[t] || (e[t] = []), e[t].push(r.properties[t]); return e }, {}), { type: "FeatureCollection", features: [t] } } } }, { "@mapbox/sexagesimal": 2, "d3-dsv": 3 }], 2: [function (e, r, t) { function n(e, r) { var t = o(e, r); return t.whole + "° " + (t.minutes ? t.minutes + "' " : "") + (t.seconds ? t.seconds + '" ' : "") + t.dir } function o(e, r) { var t = ({ lat: ["N", "S"], lon: ["E", "W"] }[r] || "")[e >= 0 ? 0 : 1], n = Math.abs(e), o = Math.floor(n), i = 60 * (n - o), a = Math.floor(i); return { whole: o, minutes: a, seconds: Math.floor(60 * (i - a)), dir: t } } function i(e, r, t) { if (r || (r = "NSEW"), "string" != typeof e) return { val: null, regex: t }; var n = (t = t || /[\s\,]*([NSEW])?\s*([\-|\—|\―]?[0-9.]+)°?\s*(?:([0-9.]+)['’′‘]\s*)?(?:([0-9.]+)(?:''|"|”|″)\s*)?([NSEW])?/gi).exec(e); if (!n) return { val: null, regex: t }; var o = n[1] || n[5]; return o && -1 === r.indexOf(o) ? { val: null, regex: t } : { val: ((n[2] ? parseFloat(n[2]) : 0) + (n[3] ? parseFloat(n[3]) / 60 : 0) + (n[4] ? parseFloat(n[4]) / 3600 : 0)) * ("S" === o || "W" === o ? -1 : 1), regex: t, raw: n[0], dim: o } } r.exports = function (e, r) { return i(e, r).val }, r.exports.pair = function (e, r) { var t = i(e = e.trim(), r); if (null === t.val) return null; var n = i(e, r, t.regex); if (null === n.val) return null; if (t.raw + n.raw !== e) return null; return t.dim ? function (e, r, t) { if ("N" === t || "S" === t) return [e, r]; if ("W" === t || "E" === t) return [r, e] }(t.val, n.val, t.dim) : [t.val, n.val] }, r.exports.format = n, r.exports.formatPair = function (e) { return n(e.lat, "lat") + " " + n(e.lon, "lon") }, r.exports.coordToDMS = o }, {}], 3: [function (e, r, t) { var n; n = this, function (e) { "use strict"; function r(e) { return new Function("d", "return {" + e.map(function (e, r) { return JSON.stringify(e) + ": d[" + r + "]" }).join(",") + "}") } function t(e) { var t = new RegExp('["' + e + "\n]"), n = e.charCodeAt(0); function o(e, r) { var t, o, i = {}, a = {}, u = [], s = e.length, l = 0, f = 0; function c() { if (l >= s) return a; if (o) return o = !1, i; var r, t = l; if (34 === e.charCodeAt(t)) { for (var u = t; u++ < s;)if (34 === e.charCodeAt(u)) { if (34 !== e.charCodeAt(u + 1)) break; ++u } return l = u + 2, 13 === (r = e.charCodeAt(u + 1)) ? (o = !0, 10 === e.charCodeAt(u + 2) && ++l) : 10 === r && (o = !0), e.slice(t + 1, u).replace(/""/g, '"') } for (; l < s;) { var f = 1; if (10 === (r = e.charCodeAt(l++))) o = !0; else if (13 === r) o = !0, 10 === e.charCodeAt(l) && (++l, ++f); else if (r !== n) continue; return e.slice(t, l - f) } return e.slice(t) } for (; (t = c()) !== a;) { for (var p = []; t !== i && t !== a;)p.push(t), t = c(); r && null == (p = r(p, f++)) || u.push(p) } return u } function i(r) { return r.map(a).join(e) } function a(e) { return null == e ? "" : t.test(e += "") ? '"' + e.replace(/\"/g, '""') + '"' : e } return { parse: function (e, t) { var n, i, a = o(e, function (e, o) { if (n) return n(e, o - 1); var a, u, s; i = e, n = t ? (u = t, s = r(a = e), function (e, r) { return u(s(e), r, a) }) : r(e) }); return a.columns = i, a }, parseRows: o, format: function (r, t) { var n, o, i; return null == t && (n = r, o = Object.create(null), i = [], n.forEach(function (e) { for (var r in e) r in o || i.push(o[r] = r) }), t = i), [t.map(a).join(e)].concat(r.map(function (r) { return t.map(function (e) { return a(r[e]) }).join(e) })).join("\n") }, formatRows: function (e) { return e.map(i).join("\n") } } } var n = t(","), o = n.parse, i = n.parseRows, a = n.format, u = n.formatRows, s = t("\t"), l = s.parse, f = s.parseRows, c = s.format, p = s.formatRows; e.dsvFormat = t, e.csvParse = o, e.csvParseRows = i, e.csvFormat = a, e.csvFormatRows = u, e.tsvParse = l, e.tsvParseRows = f, e.tsvFormat = c, e.tsvFormatRows = p, Object.defineProperty(e, "__esModule", { value: !0 }) }("object" == typeof t && void 0 !== r ? t : n.d3 = n.d3 || {}) }, {}] }, {}, [1])(1) });